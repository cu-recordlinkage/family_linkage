2025-09-03 14:41:26,302 - __main__ - ERROR - Error in main: [Errno 2] No such file or directory: '../training_pipeline/config/config.yaml'
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 45, in main
    config = load_config()
             ^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 16, in load_config
    with open(config_path, 'r') as file:
         ^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../training_pipeline/config/config.yaml'
2025-09-03 14:42:14,744 - __main__ - ERROR - Error in main: [Errno 2] No such file or directory: '../config.yaml'
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 45, in main
    config = load_config()
             ^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 16, in load_config
    with open(config_path, 'r') as file:
         ^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../config.yaml'
2025-09-03 14:42:33,489 - __main__ - ERROR - Error in main: Test dataset not found: data/test/testing_dataset.csv
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 49, in main
    raise FileNotFoundError(f"Test dataset not found: {test_dataset_path}")
FileNotFoundError: Test dataset not found: data/test/testing_dataset.csv
2025-09-03 14:44:02,303 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 14:44:02,323 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 14:44:02,328 - __main__ - INFO - Normalized column: last_name
2025-09-03 14:44:02,331 - __main__ - INFO - Normalized column: middle_name
2025-09-03 14:44:02,335 - __main__ - INFO - Normalized column: address
2025-09-03 14:44:02,337 - __main__ - INFO - Normalized column: city
2025-09-03 14:44:02,340 - __main__ - INFO - Normalized column: state
2025-09-03 14:44:02,343 - __main__ - INFO - Converted DOB to datetime
2025-09-03 14:44:02,343 - __main__ - INFO - Cleaned SSN column
2025-09-03 14:44:02,345 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 14:44:02,345 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 14:44:02,598 - __main__ - ERROR - Error in main: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Optimized edit_distance function (TRIM removed - done in normalization)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    -- No TRIM needed - already done in normalization
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.age_difference(dob1 date, dob2 date)
RETURNS double precision
LANGUAGE plpgsql
AS $function$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$function$;

-- Optimized soundex function (UPPER and regex removed - done in normalization)
CREATE OR REPLACE FUNCTION public.soundex(input_string text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $function$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL THEN
        RETURN NULL;
    END IF;

    -- No UPPER or regex needed - already normalized
    IF input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$function$;

-- Optimized create_blocking_keys_test with birth year CTE and no redundant UPPER
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := 'record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := 'record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    SELECT COUNT(*) INTO total_records 
    FROM records 
    WHERE (gid_start IS NULL OR id >= gid_start)
      AND (gid_end IS NULL OR id <= gid_end);
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Optimized with birth year CTE and no redundant operations
    EXECUTE format('
        INSERT INTO %%I (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM records r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%I(block_key)', 
                   'idx_' || table_name || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%I(id)', 
                   'idx_' || table_name || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Optimized compare_records_optimized_test with inline age/sex encoding
CREATE OR REPLACE FUNCTION compare_records_optimized_test(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    block_key_start text DEFAULT NULL,
    block_key_end text DEFAULT NULL
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    temp_table_name text;
    session_id text;
BEGIN
    start_time := clock_timestamp();
    
    session_id := 'temp_' || pg_backend_pid() || '_' || extract(epoch from clock_timestamp())::text;
    temp_table_name := 'processed_records_' || session_id;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER
    )', temp_table_name);
    
    SELECT COUNT(*) INTO total_blocks 
    FROM block_sizes 
    WHERE block_size <= max_block_size 
      AND block_size > 3
      AND (block_key_start IS NULL OR block_key >= block_key_start)
      AND (block_key_end IS NULL OR block_key < block_key_end);
    
    RAISE NOTICE 'Processing %% blocks (range: %% to %%)', 
        total_blocks, COALESCE(block_key_start, 'MIN'), COALESCE(block_key_end, 'MAX');
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND (block_key_start IS NULL OR bs.block_key >= block_key_start)
          AND (block_key_end IS NULL OR bs.block_key < block_key_end)
        ORDER BY bs.block_size
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Optimized with inline age category and sex encoding
        EXECUTE format('
            INSERT INTO %%I
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM record_blocks rb
                JOIN records r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                -- Inline sex encoding instead of function call
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                -- Inline age category instead of function call
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
        ', temp_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%I', temp_table_name) INTO total_comparisons;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'processed_records') THEN
        EXECUTE format('CREATE UNLOGGED TABLE processed_records AS SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    ELSE
        EXECUTE format('INSERT INTO processed_records SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    END IF;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep existing exhaustive function but update column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive()
RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_records FROM records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records', total_records;
    
    DROP TABLE IF EXISTS processed_records;
    CREATE UNLOGGED TABLE processed_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized exhaustive with inline calculations
    INSERT INTO processed_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        r1.id, 
        r2.id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM age_data r1
    JOIN age_data r2 ON r1.id < r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep other existing functions with updated column names where needed
CREATE OR REPLACE FUNCTION merge_blocking_tables()
RETURNS void AS $$
DECLARE
    table_record record;
    total_records bigint := 0;
    merged_count integer := 0;
BEGIN
    DROP TABLE IF EXISTS record_blocks CASCADE;
    CREATE UNLOGGED TABLE record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    );
    
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'record_blocks_worker_%%'
    LOOP
        EXECUTE format('INSERT INTO record_blocks SELECT * FROM %%I', table_record.tablename);
        
        EXECUTE format('SELECT COUNT(*) FROM %%I', table_record.tablename) INTO total_records;
        RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
        
        EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_record.tablename);
        
        merged_count := merged_count + 1;
    END LOOP;
    
    CREATE INDEX IF NOT EXISTS idx_block_key ON record_blocks(block_key);
    CREATE INDEX IF NOT EXISTS idx_gid_blocks ON record_blocks(id);
    
    DROP TABLE IF EXISTS block_sizes CASCADE;
    CREATE TABLE block_sizes AS
    SELECT block_key, COUNT(*) AS block_size
    FROM record_blocks
    GROUP BY block_key;
    
    CREATE INDEX idx_block_sizes ON block_sizes(block_key);
    
    SELECT COUNT(*) INTO total_records FROM record_blocks;
    RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
    
    SELECT COUNT(*) INTO total_records FROM block_sizes;
    RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$$ LANGUAGE plpgsql;

-- Updated process_positive_record_pairs with new column names
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $$
DECLARE
    total_pairs integer;
    start_time timestamp;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_pairs FROM labels;
    
    RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
    
    DROP TABLE IF EXISTS processed_positive_records;
    CREATE UNLOGGED TABLE processed_positive_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized with inline calculations and birth year CTE
    INSERT INTO processed_positive_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        l.from_id,
        l.to_id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM labels l
    JOIN age_data r1 ON l.from_id = r1.id
    JOIN age_data r2 ON l.to_id = r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Include remaining optimized parallel functions with updated column names...
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND bs.block_key BETWEEN block_key_start AND block_key_end
        ORDER BY bs.block_size
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%I (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                    FROM record_blocks rb
                    JOIN records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT 
                    r1_gid, r2_gid,
                    (
                        CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                        CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                        CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                    )::float,
                    edit_distance(r1_ln, r2_ln),
                    edit_distance(r1_tel, r2_tel),
                    edit_distance(r1_mi, r2_mi),
                    edit_distance(r1_zip, r2_zip),
                    edit_distance(r1_city, r2_city),
                    age_difference(r1_dob, r2_dob),
                    CASE 
                        WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                        WHEN r1_sex != r2_sex THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                        WHEN r1_ssn = r2_ssn THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                        WHEN r1_st = r2_st THEN 1
                        ELSE 0 
                    END,
                    edit_distance(r1_adr, r2_adr),
                    CASE 
                        WHEN r1_sex IS NULL THEN -1
                        WHEN r1_sex = ''M'' THEN 0
                        WHEN r1_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r2_sex IS NULL THEN -1
                        WHEN r2_sex = ''M'' THEN 0
                        WHEN r2_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r1_age_years IS NULL THEN -1
                        WHEN r1_age_years < 18 THEN 0
                        WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END,
                    CASE 
                        WHEN r2_age_years IS NULL THEN -1
                        WHEN r2_age_years < 18 THEN 0
                        WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END
                FROM record_pairs
                WHERE (
                    CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                    CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                    CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                )::float >= $4
                ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name) 
            USING block_key_val, window_start, window_end, similarity_threshold;
            
            GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
            total_comparisons := total_comparisons + curr_window_matches;
            
            window_start := window_start + window_size - overlap;
        END LOOP;
    END LOOP;
    
    RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$$ LANGUAGE plpgsql;

-- Optimized exhaustive parallel function with updated column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
    gid_start text,
    gid_end text,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('
        CREATE UNLOGGED TABLE %%I AS
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM records r
        )
        SELECT 
            r1.id as from_id, 
            r2.id as to_id,
            (
                CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
                CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
            )::float AS similarity_score,
            edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
            edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
            edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
            edit_distance(r1.zip, r2.zip) as edit_dist_zip,
            edit_distance(r1.city, r2.city) as edit_dist_city,
            age_difference(r1.dob, r2.dob) as age_diff,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END as sex_diff,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END as ssn_match,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END as state_match,
            edit_distance(r1.address, r2.address) as edit_dist_mail_address,
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END as record1_sex,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END as record2_sex,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record1_agecategory,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record2_agecategory
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        WHERE r1.id BETWEEN $1 AND $2
    ', temp_table_name) 
    USING gid_start, gid_end;
    
    RAISE NOTICE 'Created worker table %% with TRUE exhaustive comparison (no filtering)', temp_table_name;
END;
$$ LANGUAGE plpgsql;

-- Updated create_blocking_keys to accept schema and table parameters as Chris specified
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 10000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table in the job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with schema/table parameters
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_optimized to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create block_sizes table in job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_exhaustive to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create exhaustive comparisons
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            age_difference(r1.dob, r2.dob),
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.InvalidFunctionDefinition: cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 83, in main
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Optimized edit_distance function (TRIM removed - done in normalization)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    -- No TRIM needed - already done in normalization
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.age_difference(dob1 date, dob2 date)
RETURNS double precision
LANGUAGE plpgsql
AS $function$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$function$;

-- Optimized soundex function (UPPER and regex removed - done in normalization)
CREATE OR REPLACE FUNCTION public.soundex(input_string text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $function$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL THEN
        RETURN NULL;
    END IF;

    -- No UPPER or regex needed - already normalized
    IF input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$function$;

-- Optimized create_blocking_keys_test with birth year CTE and no redundant UPPER
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := 'record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := 'record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    SELECT COUNT(*) INTO total_records 
    FROM records 
    WHERE (gid_start IS NULL OR id >= gid_start)
      AND (gid_end IS NULL OR id <= gid_end);
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Optimized with birth year CTE and no redundant operations
    EXECUTE format('
        INSERT INTO %%I (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM records r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%I(block_key)', 
                   'idx_' || table_name || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%I(id)', 
                   'idx_' || table_name || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Optimized compare_records_optimized_test with inline age/sex encoding
CREATE OR REPLACE FUNCTION compare_records_optimized_test(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    block_key_start text DEFAULT NULL,
    block_key_end text DEFAULT NULL
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    temp_table_name text;
    session_id text;
BEGIN
    start_time := clock_timestamp();
    
    session_id := 'temp_' || pg_backend_pid() || '_' || extract(epoch from clock_timestamp())::text;
    temp_table_name := 'processed_records_' || session_id;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER
    )', temp_table_name);
    
    SELECT COUNT(*) INTO total_blocks 
    FROM block_sizes 
    WHERE block_size <= max_block_size 
      AND block_size > 3
      AND (block_key_start IS NULL OR block_key >= block_key_start)
      AND (block_key_end IS NULL OR block_key < block_key_end);
    
    RAISE NOTICE 'Processing %% blocks (range: %% to %%)', 
        total_blocks, COALESCE(block_key_start, 'MIN'), COALESCE(block_key_end, 'MAX');
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND (block_key_start IS NULL OR bs.block_key >= block_key_start)
          AND (block_key_end IS NULL OR bs.block_key < block_key_end)
        ORDER BY bs.block_size
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Optimized with inline age category and sex encoding
        EXECUTE format('
            INSERT INTO %%I
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM record_blocks rb
                JOIN records r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                -- Inline sex encoding instead of function call
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                -- Inline age category instead of function call
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
        ', temp_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%I', temp_table_name) INTO total_comparisons;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'processed_records') THEN
        EXECUTE format('CREATE UNLOGGED TABLE processed_records AS SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    ELSE
        EXECUTE format('INSERT INTO processed_records SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    END IF;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep existing exhaustive function but update column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive()
RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_records FROM records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records', total_records;
    
    DROP TABLE IF EXISTS processed_records;
    CREATE UNLOGGED TABLE processed_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized exhaustive with inline calculations
    INSERT INTO processed_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        r1.id, 
        r2.id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM age_data r1
    JOIN age_data r2 ON r1.id < r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep other existing functions with updated column names where needed
CREATE OR REPLACE FUNCTION merge_blocking_tables()
RETURNS void AS $$
DECLARE
    table_record record;
    total_records bigint := 0;
    merged_count integer := 0;
BEGIN
    DROP TABLE IF EXISTS record_blocks CASCADE;
    CREATE UNLOGGED TABLE record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    );
    
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'record_blocks_worker_%%'
    LOOP
        EXECUTE format('INSERT INTO record_blocks SELECT * FROM %%I', table_record.tablename);
        
        EXECUTE format('SELECT COUNT(*) FROM %%I', table_record.tablename) INTO total_records;
        RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
        
        EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_record.tablename);
        
        merged_count := merged_count + 1;
    END LOOP;
    
    CREATE INDEX IF NOT EXISTS idx_block_key ON record_blocks(block_key);
    CREATE INDEX IF NOT EXISTS idx_gid_blocks ON record_blocks(id);
    
    DROP TABLE IF EXISTS block_sizes CASCADE;
    CREATE TABLE block_sizes AS
    SELECT block_key, COUNT(*) AS block_size
    FROM record_blocks
    GROUP BY block_key;
    
    CREATE INDEX idx_block_sizes ON block_sizes(block_key);
    
    SELECT COUNT(*) INTO total_records FROM record_blocks;
    RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
    
    SELECT COUNT(*) INTO total_records FROM block_sizes;
    RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$$ LANGUAGE plpgsql;

-- Updated process_positive_record_pairs with new column names
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $$
DECLARE
    total_pairs integer;
    start_time timestamp;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_pairs FROM labels;
    
    RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
    
    DROP TABLE IF EXISTS processed_positive_records;
    CREATE UNLOGGED TABLE processed_positive_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized with inline calculations and birth year CTE
    INSERT INTO processed_positive_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        l.from_id,
        l.to_id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM labels l
    JOIN age_data r1 ON l.from_id = r1.id
    JOIN age_data r2 ON l.to_id = r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Include remaining optimized parallel functions with updated column names...
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND bs.block_key BETWEEN block_key_start AND block_key_end
        ORDER BY bs.block_size
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%I (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                    FROM record_blocks rb
                    JOIN records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT 
                    r1_gid, r2_gid,
                    (
                        CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                        CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                        CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                    )::float,
                    edit_distance(r1_ln, r2_ln),
                    edit_distance(r1_tel, r2_tel),
                    edit_distance(r1_mi, r2_mi),
                    edit_distance(r1_zip, r2_zip),
                    edit_distance(r1_city, r2_city),
                    age_difference(r1_dob, r2_dob),
                    CASE 
                        WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                        WHEN r1_sex != r2_sex THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                        WHEN r1_ssn = r2_ssn THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                        WHEN r1_st = r2_st THEN 1
                        ELSE 0 
                    END,
                    edit_distance(r1_adr, r2_adr),
                    CASE 
                        WHEN r1_sex IS NULL THEN -1
                        WHEN r1_sex = ''M'' THEN 0
                        WHEN r1_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r2_sex IS NULL THEN -1
                        WHEN r2_sex = ''M'' THEN 0
                        WHEN r2_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r1_age_years IS NULL THEN -1
                        WHEN r1_age_years < 18 THEN 0
                        WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END,
                    CASE 
                        WHEN r2_age_years IS NULL THEN -1
                        WHEN r2_age_years < 18 THEN 0
                        WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END
                FROM record_pairs
                WHERE (
                    CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                    CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                    CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                )::float >= $4
                ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name) 
            USING block_key_val, window_start, window_end, similarity_threshold;
            
            GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
            total_comparisons := total_comparisons + curr_window_matches;
            
            window_start := window_start + window_size - overlap;
        END LOOP;
    END LOOP;
    
    RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$$ LANGUAGE plpgsql;

-- Optimized exhaustive parallel function with updated column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
    gid_start text,
    gid_end text,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('
        CREATE UNLOGGED TABLE %%I AS
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM records r
        )
        SELECT 
            r1.id as from_id, 
            r2.id as to_id,
            (
                CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
                CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
            )::float AS similarity_score,
            edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
            edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
            edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
            edit_distance(r1.zip, r2.zip) as edit_dist_zip,
            edit_distance(r1.city, r2.city) as edit_dist_city,
            age_difference(r1.dob, r2.dob) as age_diff,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END as sex_diff,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END as ssn_match,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END as state_match,
            edit_distance(r1.address, r2.address) as edit_dist_mail_address,
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END as record1_sex,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END as record2_sex,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record1_agecategory,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record2_agecategory
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        WHERE r1.id BETWEEN $1 AND $2
    ', temp_table_name) 
    USING gid_start, gid_end;
    
    RAISE NOTICE 'Created worker table %% with TRUE exhaustive comparison (no filtering)', temp_table_name;
END;
$$ LANGUAGE plpgsql;

-- Updated create_blocking_keys to accept schema and table parameters as Chris specified
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 10000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table in the job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with schema/table parameters
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_optimized to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create block_sizes table in job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_exhaustive to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create exhaustive comparisons
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            age_difference(r1.dob, r2.dob),
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:47:24,220 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 14:47:24,243 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 14:47:24,248 - __main__ - INFO - Normalized column: last_name
2025-09-03 14:47:24,251 - __main__ - INFO - Normalized column: middle_name
2025-09-03 14:47:24,255 - __main__ - INFO - Normalized column: address
2025-09-03 14:47:24,258 - __main__ - INFO - Normalized column: city
2025-09-03 14:47:24,260 - __main__ - INFO - Normalized column: state
2025-09-03 14:47:24,264 - __main__ - INFO - Converted DOB to datetime
2025-09-03 14:47:24,264 - __main__ - INFO - Cleaned SSN column
2025-09-03 14:47:24,265 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 14:47:24,265 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 14:47:24,471 - __main__ - ERROR - Error in main: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Optimized edit_distance function (TRIM removed - done in normalization)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    -- No TRIM needed - already done in normalization
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.age_difference(dob1 date, dob2 date)
RETURNS double precision
LANGUAGE plpgsql
AS $function$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$function$;

-- Optimized soundex function (UPPER and regex removed - done in normalization)
CREATE OR REPLACE FUNCTION public.soundex(input_string text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $function$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL THEN
        RETURN NULL;
    END IF;

    -- No UPPER or regex needed - already normalized
    IF input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$function$;

-- Optimized create_blocking_keys_test with birth year CTE and no redundant UPPER
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := 'record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := 'record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    SELECT COUNT(*) INTO total_records 
    FROM records 
    WHERE (gid_start IS NULL OR id >= gid_start)
      AND (gid_end IS NULL OR id <= gid_end);
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Optimized with birth year CTE and no redundant operations
    EXECUTE format('
        INSERT INTO %%I (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM records r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%I(block_key)', 
                   'idx_' || table_name || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%I(id)', 
                   'idx_' || table_name || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Optimized compare_records_optimized_test with inline age/sex encoding
CREATE OR REPLACE FUNCTION compare_records_optimized_test(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    block_key_start text DEFAULT NULL,
    block_key_end text DEFAULT NULL
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    temp_table_name text;
    session_id text;
BEGIN
    start_time := clock_timestamp();
    
    session_id := 'temp_' || pg_backend_pid() || '_' || extract(epoch from clock_timestamp())::text;
    temp_table_name := 'processed_records_' || session_id;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER
    )', temp_table_name);
    
    SELECT COUNT(*) INTO total_blocks 
    FROM block_sizes 
    WHERE block_size <= max_block_size 
      AND block_size > 3
      AND (block_key_start IS NULL OR block_key >= block_key_start)
      AND (block_key_end IS NULL OR block_key < block_key_end);
    
    RAISE NOTICE 'Processing %% blocks (range: %% to %%)', 
        total_blocks, COALESCE(block_key_start, 'MIN'), COALESCE(block_key_end, 'MAX');
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND (block_key_start IS NULL OR bs.block_key >= block_key_start)
          AND (block_key_end IS NULL OR bs.block_key < block_key_end)
        ORDER BY bs.block_size
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Optimized with inline age category and sex encoding
        EXECUTE format('
            INSERT INTO %%I
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM record_blocks rb
                JOIN records r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                -- Inline sex encoding instead of function call
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                -- Inline age category instead of function call
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
        ', temp_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%I', temp_table_name) INTO total_comparisons;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'processed_records') THEN
        EXECUTE format('CREATE UNLOGGED TABLE processed_records AS SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    ELSE
        EXECUTE format('INSERT INTO processed_records SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    END IF;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep existing exhaustive function but update column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive()
RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_records FROM records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records', total_records;
    
    DROP TABLE IF EXISTS processed_records;
    CREATE UNLOGGED TABLE processed_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized exhaustive with inline calculations
    INSERT INTO processed_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        r1.id, 
        r2.id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM age_data r1
    JOIN age_data r2 ON r1.id < r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep other existing functions with updated column names where needed
CREATE OR REPLACE FUNCTION merge_blocking_tables()
RETURNS void AS $$
DECLARE
    table_record record;
    total_records bigint := 0;
    merged_count integer := 0;
BEGIN
    DROP TABLE IF EXISTS record_blocks CASCADE;
    CREATE UNLOGGED TABLE record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    );
    
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'record_blocks_worker_%%'
    LOOP
        EXECUTE format('INSERT INTO record_blocks SELECT * FROM %%I', table_record.tablename);
        
        EXECUTE format('SELECT COUNT(*) FROM %%I', table_record.tablename) INTO total_records;
        RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
        
        EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_record.tablename);
        
        merged_count := merged_count + 1;
    END LOOP;
    
    CREATE INDEX IF NOT EXISTS idx_block_key ON record_blocks(block_key);
    CREATE INDEX IF NOT EXISTS idx_gid_blocks ON record_blocks(id);
    
    DROP TABLE IF EXISTS block_sizes CASCADE;
    CREATE TABLE block_sizes AS
    SELECT block_key, COUNT(*) AS block_size
    FROM record_blocks
    GROUP BY block_key;
    
    CREATE INDEX idx_block_sizes ON block_sizes(block_key);
    
    SELECT COUNT(*) INTO total_records FROM record_blocks;
    RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
    
    SELECT COUNT(*) INTO total_records FROM block_sizes;
    RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$$ LANGUAGE plpgsql;

-- Updated process_positive_record_pairs with new column names
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $$
DECLARE
    total_pairs integer;
    start_time timestamp;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_pairs FROM labels;
    
    RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
    
    DROP TABLE IF EXISTS processed_positive_records;
    CREATE UNLOGGED TABLE processed_positive_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized with inline calculations and birth year CTE
    INSERT INTO processed_positive_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        l.from_id,
        l.to_id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM labels l
    JOIN age_data r1 ON l.from_id = r1.id
    JOIN age_data r2 ON l.to_id = r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Include remaining optimized parallel functions with updated column names...
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND bs.block_key BETWEEN block_key_start AND block_key_end
        ORDER BY bs.block_size
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%I (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                    FROM record_blocks rb
                    JOIN records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT 
                    r1_gid, r2_gid,
                    (
                        CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                        CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                        CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                    )::float,
                    edit_distance(r1_ln, r2_ln),
                    edit_distance(r1_tel, r2_tel),
                    edit_distance(r1_mi, r2_mi),
                    edit_distance(r1_zip, r2_zip),
                    edit_distance(r1_city, r2_city),
                    age_difference(r1_dob, r2_dob),
                    CASE 
                        WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                        WHEN r1_sex != r2_sex THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                        WHEN r1_ssn = r2_ssn THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                        WHEN r1_st = r2_st THEN 1
                        ELSE 0 
                    END,
                    edit_distance(r1_adr, r2_adr),
                    CASE 
                        WHEN r1_sex IS NULL THEN -1
                        WHEN r1_sex = ''M'' THEN 0
                        WHEN r1_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r2_sex IS NULL THEN -1
                        WHEN r2_sex = ''M'' THEN 0
                        WHEN r2_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r1_age_years IS NULL THEN -1
                        WHEN r1_age_years < 18 THEN 0
                        WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END,
                    CASE 
                        WHEN r2_age_years IS NULL THEN -1
                        WHEN r2_age_years < 18 THEN 0
                        WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END
                FROM record_pairs
                WHERE (
                    CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                    CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                    CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                )::float >= $4
                ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name) 
            USING block_key_val, window_start, window_end, similarity_threshold;
            
            GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
            total_comparisons := total_comparisons + curr_window_matches;
            
            window_start := window_start + window_size - overlap;
        END LOOP;
    END LOOP;
    
    RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$$ LANGUAGE plpgsql;

-- Optimized exhaustive parallel function with updated column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
    gid_start text,
    gid_end text,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('
        CREATE UNLOGGED TABLE %%I AS
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM records r
        )
        SELECT 
            r1.id as from_id, 
            r2.id as to_id,
            (
                CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
                CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
            )::float AS similarity_score,
            edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
            edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
            edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
            edit_distance(r1.zip, r2.zip) as edit_dist_zip,
            edit_distance(r1.city, r2.city) as edit_dist_city,
            age_difference(r1.dob, r2.dob) as age_diff,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END as sex_diff,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END as ssn_match,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END as state_match,
            edit_distance(r1.address, r2.address) as edit_dist_mail_address,
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END as record1_sex,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END as record2_sex,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record1_agecategory,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record2_agecategory
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        WHERE r1.id BETWEEN $1 AND $2
    ', temp_table_name) 
    USING gid_start, gid_end;
    
    RAISE NOTICE 'Created worker table %% with TRUE exhaustive comparison (no filtering)', temp_table_name;
END;
$$ LANGUAGE plpgsql;

-- Updated create_blocking_keys to accept schema and table parameters as Chris specified
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 10000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table in the job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with schema/table parameters
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_optimized to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create block_sizes table in job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_exhaustive to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create exhaustive comparisons
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            age_difference(r1.dob, r2.dob),
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.InvalidFunctionDefinition: cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 83, in main
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Optimized edit_distance function (TRIM removed - done in normalization)
CREATE OR REPLACE FUNCTION edit_distance(str1 text, str2 text)
RETURNS float AS $$
DECLARE
    m integer;
    n integer;
    dp float[];
    i integer;
    j integer;
    width integer;
BEGIN
    IF str1 IS NULL AND str2 IS NULL THEN
        RETURN -1;
    ELSIF str1 IS NULL OR str2 IS NULL THEN
        RETURN 100;
    END IF;
    
    -- No TRIM needed - already done in normalization
    m := LENGTH(str1);
    n := LENGTH(str2);
    
    IF m = 0 AND n = 0 THEN
        RETURN 1.0;
    END IF;
    
    width := n + 1;
    
    dp := array_fill(0::float, ARRAY[(m + 1) * (n + 1)]);
    
    FOR i IN 0..m LOOP
        dp[i * width] := i::float;
    END LOOP;
    
    FOR j IN 0..n LOOP
        dp[j] := j::float;
    END LOOP;
    
    FOR i IN 1..m LOOP
        FOR j IN 1..n LOOP
            IF SUBSTRING(str1, i, 1) = SUBSTRING(str2, j, 1) THEN
                dp[i * width + j] := dp[(i-1) * width + (j-1)];
            ELSE
                dp[i * width + j] := 1 + LEAST(
                    dp[(i-1) * width + j],     
                    dp[i * width + (j-1)],      
                    dp[(i-1) * width + (j-1)]   
                );
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN dp[m * width + n] / GREATEST(m, n)::float;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION public.age_difference(dob1 date, dob2 date)
RETURNS double precision
LANGUAGE plpgsql
AS $function$
DECLARE
    days_diff float;
    age_diff_years float;
BEGIN
    IF dob1 IS NULL AND dob2 IS NULL THEN
        RETURN 10;
    ELSIF dob1 IS NULL OR dob2 IS NULL THEN
        RETURN 100;
    END IF;
  
    days_diff := (dob1 - dob2);
    age_diff_years := days_diff / 365.25;
    
    RETURN GREATEST(LEAST(age_diff_years / 100.0, 1.0), -1.0);
EXCEPTION
    WHEN OTHERS THEN
        RETURN 50;
END;
$function$;

-- Optimized soundex function (UPPER and regex removed - done in normalization)
CREATE OR REPLACE FUNCTION public.soundex(input_string text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $function$
DECLARE
    soundex_code TEXT;
    current_char CHAR;
    previous_digit CHAR;
    current_digit CHAR;
    i INT;
BEGIN
    IF input_string IS NULL THEN
        RETURN NULL;
    END IF;

    -- No UPPER or regex needed - already normalized
    IF input_string = '' THEN
        RETURN NULL;
    END IF;

    soundex_code := LEFT(input_string, 1);
    previous_digit := '0';

    FOR i IN 2..COALESCE(LENGTH(input_string), 1) LOOP
        current_char := SUBSTRING(input_string FROM i FOR 1);
        CASE current_char
            WHEN 'B', 'F', 'P', 'V' THEN current_digit := '1';
            WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN current_digit := '2';
            WHEN 'D', 'T' THEN current_digit := '3';
            WHEN 'L' THEN current_digit := '4';
            WHEN 'M', 'N' THEN current_digit := '5';
            WHEN 'R' THEN current_digit := '6';
            ELSE current_digit := '0';
        END CASE;

        IF current_digit <> previous_digit AND current_digit <> '0' THEN
            soundex_code := soundex_code || current_digit;
        END IF;

        previous_digit := current_digit;
    END LOOP;

    soundex_code := soundex_code || '0000';
    RETURN LEFT(soundex_code, 4);
END;
$function$;

-- Optimized create_blocking_keys_test with birth year CTE and no redundant UPPER
CREATE OR REPLACE FUNCTION create_blocking_keys_test(
    batch_size integer DEFAULT 10000,
    gid_start text DEFAULT NULL,
    gid_end text DEFAULT NULL,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    IF table_suffix IS NULL OR table_suffix = '' THEN
        table_name := 'record_blocks';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        table_name := 'record_blocks_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', table_name);
    
    SELECT COUNT(*) INTO total_records 
    FROM records 
    WHERE (gid_start IS NULL OR id >= gid_start)
      AND (gid_end IS NULL OR id <= gid_end);
    
    RAISE NOTICE 'Processing %% records for table %% (range: %% to %%)', 
        total_records, table_name, COALESCE(gid_start, 'MIN'), COALESCE(gid_end, 'MAX');
    
    -- Optimized with birth year CTE and no redundant operations
    EXECUTE format('
        INSERT INTO %%I (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM records r
            WHERE ($1 IS NULL OR r.id >= $1)
              AND ($2 IS NULL OR r.id <= $2)
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', table_name) USING gid_start, gid_end;
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    EXECUTE format('CREATE INDEX %%I ON %%I(block_key)', 
                   'idx_' || table_name || '_block_key', table_name);
    EXECUTE format('CREATE INDEX %%I ON %%I(id)', 
                   'idx_' || table_name || '_gid', table_name);
    
    RAISE NOTICE 'Table %% created with %% entries in %%', 
        table_name, processed_records, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Optimized compare_records_optimized_test with inline age/sex encoding
CREATE OR REPLACE FUNCTION compare_records_optimized_test(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    block_key_start text DEFAULT NULL,
    block_key_end text DEFAULT NULL
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    temp_table_name text;
    session_id text;
BEGIN
    start_time := clock_timestamp();
    
    session_id := 'temp_' || pg_backend_pid() || '_' || extract(epoch from clock_timestamp())::text;
    temp_table_name := 'processed_records_' || session_id;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER
    )', temp_table_name);
    
    SELECT COUNT(*) INTO total_blocks 
    FROM block_sizes 
    WHERE block_size <= max_block_size 
      AND block_size > 3
      AND (block_key_start IS NULL OR block_key >= block_key_start)
      AND (block_key_end IS NULL OR block_key < block_key_end);
    
    RAISE NOTICE 'Processing %% blocks (range: %% to %%)', 
        total_blocks, COALESCE(block_key_start, 'MIN'), COALESCE(block_key_end, 'MAX');
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND (block_key_start IS NULL OR bs.block_key >= block_key_start)
          AND (block_key_end IS NULL OR bs.block_key < block_key_end)
        ORDER BY bs.block_size
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Optimized with inline age category and sex encoding
        EXECUTE format('
            INSERT INTO %%I
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM record_blocks rb
                JOIN records r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                -- Inline sex encoding instead of function call
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                -- Inline age category instead of function call
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
        ', temp_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%I', temp_table_name) INTO total_comparisons;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'processed_records') THEN
        EXECUTE format('CREATE UNLOGGED TABLE processed_records AS SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    ELSE
        EXECUTE format('INSERT INTO processed_records SELECT * FROM %%I', temp_table_name);
        EXECUTE format('DROP TABLE %%I', temp_table_name);
    END IF;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep existing exhaustive function but update column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive()
RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_records FROM records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records', total_records;
    
    DROP TABLE IF EXISTS processed_records;
    CREATE UNLOGGED TABLE processed_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized exhaustive with inline calculations
    INSERT INTO processed_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        r1.id, 
        r2.id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM age_data r1
    JOIN age_data r2 ON r1.id < r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Keep other existing functions with updated column names where needed
CREATE OR REPLACE FUNCTION merge_blocking_tables()
RETURNS void AS $$
DECLARE
    table_record record;
    total_records bigint := 0;
    merged_count integer := 0;
BEGIN
    DROP TABLE IF EXISTS record_blocks CASCADE;
    CREATE UNLOGGED TABLE record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    );
    
    FOR table_record IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename LIKE 'record_blocks_worker_%%'
    LOOP
        EXECUTE format('INSERT INTO record_blocks SELECT * FROM %%I', table_record.tablename);
        
        EXECUTE format('SELECT COUNT(*) FROM %%I', table_record.tablename) INTO total_records;
        RAISE NOTICE 'Merged %% records from %%', total_records, table_record.tablename;
        
        EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', table_record.tablename);
        
        merged_count := merged_count + 1;
    END LOOP;
    
    CREATE INDEX IF NOT EXISTS idx_block_key ON record_blocks(block_key);
    CREATE INDEX IF NOT EXISTS idx_gid_blocks ON record_blocks(id);
    
    DROP TABLE IF EXISTS block_sizes CASCADE;
    CREATE TABLE block_sizes AS
    SELECT block_key, COUNT(*) AS block_size
    FROM record_blocks
    GROUP BY block_key;
    
    CREATE INDEX idx_block_sizes ON block_sizes(block_key);
    
    SELECT COUNT(*) INTO total_records FROM record_blocks;
    RAISE NOTICE 'Merged %% worker tables. Final record_blocks table has %% records', merged_count, total_records;
    
    SELECT COUNT(*) INTO total_records FROM block_sizes;
    RAISE NOTICE 'Created %% unique blocks in block_sizes table', total_records;
END;
$$ LANGUAGE plpgsql;

-- Updated process_positive_record_pairs with new column names
CREATE OR REPLACE FUNCTION process_positive_record_pairs() 
RETURNS void AS $$
DECLARE
    total_pairs integer;
    start_time timestamp;
BEGIN
    start_time := clock_timestamp();
    
    SELECT COUNT(*) INTO total_pairs FROM labels;
    
    RAISE NOTICE 'Starting processing of %% record pairs', total_pairs;
    
    DROP TABLE IF EXISTS processed_positive_records;
    CREATE UNLOGGED TABLE processed_positive_records (
        from_id TEXT,
        to_id TEXT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    );
    
    -- Optimized with inline calculations and birth year CTE
    INSERT INTO processed_positive_records
    WITH age_data AS (
        SELECT 
            r.*,
            EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
        FROM records r
    )
    SELECT 
        l.from_id,
        l.to_id,
        edit_distance(r1.last_name, r2.last_name),
        edit_distance(r1.phone, r2.phone),
        edit_distance(r1.middle_name, r2.middle_name),
        edit_distance(r1.zip, r2.zip),
        edit_distance(r1.city, r2.city),
        age_difference(r1.dob, r2.dob),
        CASE 
            WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
            WHEN r1.sex != r2.sex THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
            WHEN r1.ssn = r2.ssn THEN 1
            ELSE 0 
        END,
        CASE 
            WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
            WHEN r1.state = r2.state THEN 1
            ELSE 0 
        END,
        edit_distance(r1.address, r2.address),
        -- Inline sex encoding
        CASE 
            WHEN r1.sex IS NULL THEN -1
            WHEN r1.sex = 'M' THEN 0
            WHEN r1.sex = 'F' THEN 1
            ELSE -1
        END,
        CASE 
            WHEN r2.sex IS NULL THEN -1
            WHEN r2.sex = 'M' THEN 0
            WHEN r2.sex = 'F' THEN 1
            ELSE -1
        END,
        -- Inline age category
        CASE 
            WHEN r1.age_years IS NULL THEN -1
            WHEN r1.age_years < 18 THEN 0
            WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END,
        CASE 
            WHEN r2.age_years IS NULL THEN -1
            WHEN r2.age_years < 18 THEN 0
            WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
            ELSE 2
        END
    FROM labels l
    JOIN age_data r1 ON l.from_id = r1.id
    JOIN age_data r2 ON l.to_id = r2.id
    ON CONFLICT (from_id, to_id) DO NOTHING;
    
    RAISE NOTICE 'Processing complete in %%', clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Include remaining optimized parallel functions with updated column names...
CREATE OR REPLACE FUNCTION compare_records_optimized_parallel(
    block_key_start text,
    block_key_end text,
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100,
    overlap integer DEFAULT 50,
    similarity_threshold float DEFAULT 2.0,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
    block_key_val text;
    block_size_val integer;
    window_start integer;
    window_end integer;
    total_comparisons integer := 0;
    curr_window_matches integer := 0;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('CREATE UNLOGGED TABLE %%I (
        from_id TEXT,
        to_id TEXT,
        similarity_score FLOAT,
        edit_dist_ln FLOAT,
        edit_dist_phone_num FLOAT,
        edit_dist_mn FLOAT,
        edit_dist_zip FLOAT,
        edit_dist_city FLOAT,
        age_diff FLOAT,
        sex_diff INTEGER,
        ssn_match INTEGER,
        state_match INTEGER,
        edit_dist_mail_address FLOAT,
        record1_sex INTEGER,
        record2_sex INTEGER,
        record1_agecategory INTEGER,
        record2_agecategory INTEGER,
        PRIMARY KEY (from_id, to_id)
    )', temp_table_name);
    
    FOR block_key_val, block_size_val IN 
        SELECT bs.block_key, bs.block_size
        FROM block_sizes bs
        WHERE bs.block_size <= max_block_size 
          AND bs.block_size > 3
          AND bs.block_key BETWEEN block_key_start AND block_key_end
        ORDER BY bs.block_size
    LOOP
        window_start := 1;
        
        WHILE window_start <= block_size_val LOOP
            window_end := LEAST(window_start + window_size - 1, block_size_val);
            
            EXECUTE format('
                INSERT INTO %%I (
                    from_id, to_id, similarity_score, edit_dist_ln, edit_dist_phone_num,
                    edit_dist_mn, edit_dist_zip, edit_dist_city, age_diff,
                    sex_diff, ssn_match, state_match, edit_dist_mail_address,
                    record1_sex, record2_sex, record1_agecategory, record2_agecategory
                )
                WITH block_records AS (
                    SELECT 
                        r.*,
                        ROW_NUMBER() OVER (
                            PARTITION BY rb.block_key 
                            ORDER BY rb.sort_key, r.id
                        ) AS row_num,
                        EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                    FROM record_blocks rb
                    JOIN records r ON rb.id = r.id
                    WHERE rb.block_key = $1
                ),
                record_pairs AS (
                    SELECT 
                        r1.id AS r1_gid,
                        r1.last_name AS r1_ln, r1.middle_name AS r1_mi, r1.dob AS r1_dob,
                        r1.city AS r1_city, r1.zip AS r1_zip, r1.phone AS r1_tel,
                        r1.state AS r1_st, r1.address AS r1_adr, r1.sex AS r1_sex, r1.ssn AS r1_ssn,
                        r1.age_years AS r1_age_years,
                        r2.id AS r2_gid,
                        r2.last_name AS r2_ln, r2.middle_name AS r2_mi, r2.dob AS r2_dob,
                        r2.city AS r2_city, r2.zip AS r2_zip, r2.phone AS r2_tel,
                        r2.state AS r2_st, r2.address AS r2_adr, r2.sex AS r2_sex, r2.ssn AS r2_ssn,
                        r2.age_years AS r2_age_years
                    FROM block_records r1
                    JOIN block_records r2 ON r1.row_num < r2.row_num
                        AND r1.row_num BETWEEN $2 AND $3
                        AND r2.row_num BETWEEN $2 AND $3
                )
                SELECT 
                    r1_gid, r2_gid,
                    (
                        CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                        CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                        CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                        CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                    )::float,
                    edit_distance(r1_ln, r2_ln),
                    edit_distance(r1_tel, r2_tel),
                    edit_distance(r1_mi, r2_mi),
                    edit_distance(r1_zip, r2_zip),
                    edit_distance(r1_city, r2_city),
                    age_difference(r1_dob, r2_dob),
                    CASE 
                        WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                        WHEN r1_sex != r2_sex THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                        WHEN r1_ssn = r2_ssn THEN 1
                        ELSE 0 
                    END,
                    CASE 
                        WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                        WHEN r1_st = r2_st THEN 1
                        ELSE 0 
                    END,
                    edit_distance(r1_adr, r2_adr),
                    CASE 
                        WHEN r1_sex IS NULL THEN -1
                        WHEN r1_sex = ''M'' THEN 0
                        WHEN r1_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r2_sex IS NULL THEN -1
                        WHEN r2_sex = ''M'' THEN 0
                        WHEN r2_sex = ''F'' THEN 1
                        ELSE -1
                    END,
                    CASE 
                        WHEN r1_age_years IS NULL THEN -1
                        WHEN r1_age_years < 18 THEN 0
                        WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END,
                    CASE 
                        WHEN r2_age_years IS NULL THEN -1
                        WHEN r2_age_years < 18 THEN 0
                        WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                        ELSE 2
                    END
                FROM record_pairs
                WHERE (
                    CASE WHEN edit_distance(r1_ln, r2_ln) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN edit_distance(r1_mi, r2_mi) <= 0.5 THEN 1 ELSE 0 END +
                    CASE WHEN age_difference(r1_dob, r2_dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                    CASE WHEN r1_st = r2_st THEN 1 ELSE 0 END +
                    CASE WHEN r1_city = r2_city THEN 1 ELSE 0 END
                )::float >= $4
                ON CONFLICT (from_id, to_id) DO NOTHING
            ', temp_table_name) 
            USING block_key_val, window_start, window_end, similarity_threshold;
            
            GET DIAGNOSTICS curr_window_matches = ROW_COUNT;
            total_comparisons := total_comparisons + curr_window_matches;
            
            window_start := window_start + window_size - overlap;
        END LOOP;
    END LOOP;
    
    RAISE NOTICE 'Created worker table %% with %% comparisons using sliding window', temp_table_name, total_comparisons;
END;
$$ LANGUAGE plpgsql;

-- Optimized exhaustive parallel function with updated column names
CREATE OR REPLACE FUNCTION compare_records_exhaustive_parallel(
    gid_start text,
    gid_end text,
    table_suffix text DEFAULT ''
) RETURNS void AS $$
DECLARE
    temp_table_name text;
BEGIN
    IF table_suffix IS NULL OR table_suffix = '' THEN
        temp_table_name := 'processed_records_temp';
    ELSE
        table_suffix := regexp_replace(table_suffix, '[^a-zA-Z0-9_]', '', 'g');
        temp_table_name := 'processed_records_worker_' || table_suffix;
    END IF;
    
    EXECUTE format('DROP TABLE IF EXISTS %%I CASCADE', temp_table_name);
    
    EXECUTE format('
        CREATE UNLOGGED TABLE %%I AS
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM records r
        )
        SELECT 
            r1.id as from_id, 
            r2.id as to_id,
            (
                CASE WHEN edit_distance(r1.last_name, r2.last_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN edit_distance(r1.middle_name, r2.middle_name) <= 0.5 THEN 1 ELSE 0 END +
                CASE WHEN age_difference(r1.dob, r2.dob) BETWEEN -0.55 AND 0.55 THEN 1 ELSE 0 END +
                CASE WHEN r1.state = r2.state THEN 1 ELSE 0 END +
                CASE WHEN r1.city = r2.city THEN 1 ELSE 0 END
            )::float AS similarity_score,
            edit_distance(r1.last_name, r2.last_name) as edit_dist_ln,
            edit_distance(r1.phone, r2.phone) as edit_dist_phone_num,
            edit_distance(r1.middle_name, r2.middle_name) as edit_dist_mn,
            edit_distance(r1.zip, r2.zip) as edit_dist_zip,
            edit_distance(r1.city, r2.city) as edit_dist_city,
            age_difference(r1.dob, r2.dob) as age_diff,
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END as sex_diff,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END as ssn_match,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END as state_match,
            edit_distance(r1.address, r2.address) as edit_dist_mail_address,
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END as record1_sex,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END as record2_sex,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record1_agecategory,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END as record2_agecategory
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        WHERE r1.id BETWEEN $1 AND $2
    ', temp_table_name) 
    USING gid_start, gid_end;
    
    RAISE NOTICE 'Created worker table %% with TRUE exhaustive comparison (no filtering)', temp_table_name;
END;
$$ LANGUAGE plpgsql;

-- Updated create_blocking_keys to accept schema and table parameters as Chris specified
CREATE OR REPLACE FUNCTION create_blocking_keys(
    batch_size integer DEFAULT 10000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    processed_records integer := 0;
    start_time timestamp;
    full_table_name text;
    rec record;
BEGIN
    start_time := clock_timestamp();
    
    -- Build full table name
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    
    -- Drop and recreate record_blocks table in the job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.record_blocks CASCADE', job_schema);
    EXECUTE format('CREATE UNLOGGED TABLE %%I.record_blocks (
        id TEXT,
        block_key TEXT,
        sort_key TEXT
    )', job_schema);
    
    -- Get total record count
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Processing %% records from %% for blocking keys', total_records, full_table_name;
    
    -- Create blocking keys with schema/table parameters
    EXECUTE format('
        INSERT INTO %%I.record_blocks (id, block_key, sort_key)
        WITH record_data AS (
            SELECT 
                r.id, 
                r.last_name, 
                r.zip, 
                r.address,
                r.dob,
                r.sex,
                EXTRACT(YEAR FROM r.dob) as birth_year,
                soundex(r.last_name) as ln_soundex,
                LEFT(r.last_name, 6) as ln_prefix
            FROM %%s r
        )
        SELECT id, block_key, sort_key FROM (
            SELECT 
                id,
                ''N_'' || COALESCE(ln_soundex, ''NULL'') || ''_'' || COALESCE(ln_prefix, ''NULL'') as block_key,
                COALESCE(last_name, '''') || ''|'' || COALESCE(address, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''A_'' || COALESCE(LEFT(zip, 3), ''NA'') || ''_'' || COALESCE(LEFT(address, 6), ''NA'') as block_key,
                COALESCE(address, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            
            UNION ALL
            
            SELECT 
                id,
                ''D_'' || COALESCE(birth_year::TEXT, ''NA'') || ''_'' || COALESCE(sex, ''NA'') || ''_'' || COALESCE(ln_soundex, ''NULL'') as block_key,
                COALESCE(birth_year::TEXT, ''NA'') || ''|'' || COALESCE(sex, '''') || ''|'' || COALESCE(last_name, '''') as sort_key
            FROM record_data
            WHERE birth_year IS NOT NULL
        ) blocks
    ', job_schema, full_table_name);
    
    GET DIAGNOSTICS processed_records = ROW_COUNT;
    
    -- Create indexes
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_block_key ON %%I.record_blocks(block_key)', 
                   job_schema, job_schema);
    EXECUTE format('CREATE INDEX idx_%%I_record_blocks_gid ON %%I.record_blocks(id)', 
                   job_schema, job_schema);
    
    RAISE NOTICE 'Blocking keys created: %% entries in %% for schema %%', 
        processed_records, clock_timestamp() - start_time, job_schema;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_optimized to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    max_block_size integer DEFAULT 500,
    window_size integer DEFAULT 100, 
    overlap integer DEFAULT 50,
    chunk_size integer DEFAULT 1000,
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_blocks integer;
    processed_blocks integer := 0;
    processed_records integer := 0;
    block_key_val text;
    block_size_val integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    -- Create block_sizes table in job schema
    EXECUTE format('DROP TABLE IF EXISTS %%I.block_sizes CASCADE', job_schema);
    EXECUTE format('CREATE TABLE %%I.block_sizes AS
        SELECT block_key, COUNT(*) AS block_size
        FROM %%I.record_blocks
        GROUP BY block_key', job_schema, job_schema);
    
    EXECUTE format('CREATE INDEX idx_%%I_block_sizes ON %%I.block_sizes(block_key)', 
                   job_schema, job_schema);
    
    -- Get total blocks to process
    EXECUTE format('SELECT COUNT(*) FROM %%I.block_sizes 
                    WHERE block_size <= %%s AND block_size > 3', 
                   job_schema, max_block_size) INTO total_blocks;
    
    RAISE NOTICE 'Processing %% blocks in schema %% with max size %%', 
        total_blocks, job_schema, max_block_size;
    
    -- Process each block
    FOR block_key_val, block_size_val IN 
        EXECUTE format('SELECT bs.block_key, bs.block_size
                       FROM %%I.block_sizes bs
                       WHERE bs.block_size <= %%s AND bs.block_size > 3
                       ORDER BY bs.block_size', job_schema, max_block_size)
    LOOP
        processed_blocks := processed_blocks + 1;
        
        -- Insert comparisons for this block
        EXECUTE format('
            INSERT INTO %%s
            WITH block_records AS (
                SELECT 
                    r.*,
                    ROW_NUMBER() OVER (ORDER BY rb.sort_key, r.id) AS row_num,
                    EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
                FROM %%I.record_blocks rb
                JOIN %%s r ON rb.id = r.id
                WHERE rb.block_key = $1
            ),
            record_pairs AS (
                SELECT 
                    r1.id AS from_id,
                    r2.id AS to_id,
                    r1.last_name AS r1_ln, r2.last_name AS r2_ln,
                    r1.middle_name AS r1_mi, r2.middle_name AS r2_mi,
                    r1.dob AS r1_dob, r2.dob AS r2_dob,
                    r1.city AS r1_city, r2.city AS r2_city,
                    r1.zip AS r1_zip, r2.zip AS r2_zip,
                    r1.phone AS r1_tel, r2.phone AS r2_tel,
                    r1.state AS r1_st, r2.state AS r2_st,
                    r1.address AS r1_adr, r2.address AS r2_adr,
                    r1.sex AS r1_sex, r2.sex AS r2_sex,
                    r1.ssn AS r1_ssn, r2.ssn AS r2_ssn,
                    r1.age_years AS r1_age_years, r2.age_years AS r2_age_years
                FROM block_records r1
                JOIN block_records r2 ON r1.row_num < r2.row_num
            )
            SELECT 
                from_id, to_id,
                edit_distance(r1_ln, r2_ln),
                edit_distance(r1_tel, r2_tel),
                edit_distance(r1_mi, r2_mi),
                edit_distance(r1_zip, r2_zip),
                edit_distance(r1_city, r2_city),
                age_difference(r1_dob, r2_dob),
                CASE 
                    WHEN r1_sex IS NULL OR r2_sex IS NULL THEN -1
                    WHEN r1_sex != r2_sex THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_ssn IS NULL OR r2_ssn IS NULL THEN -1
                    WHEN r1_ssn = r2_ssn THEN 1
                    ELSE 0 
                END,
                CASE 
                    WHEN r1_st IS NULL OR r2_st IS NULL THEN -1
                    WHEN r1_st = r2_st THEN 1
                    ELSE 0 
                END,
                edit_distance(r1_adr, r2_adr),
                CASE 
                    WHEN r1_sex IS NULL THEN -1
                    WHEN r1_sex = ''M'' THEN 0
                    WHEN r1_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r2_sex IS NULL THEN -1
                    WHEN r2_sex = ''M'' THEN 0
                    WHEN r2_sex = ''F'' THEN 1
                    ELSE -1
                END,
                CASE 
                    WHEN r1_age_years IS NULL THEN -1
                    WHEN r1_age_years < 18 THEN 0
                    WHEN r1_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END,
                CASE 
                    WHEN r2_age_years IS NULL THEN -1
                    WHEN r2_age_years < 18 THEN 0
                    WHEN r2_age_years BETWEEN 18 AND 50 THEN 1
                    ELSE 2
                END
            FROM record_pairs
            ON CONFLICT (from_id, to_id) DO NOTHING
        ', processed_table_name, job_schema, full_table_name) USING block_key_val;
        
        processed_records := processed_records + block_size_val;
        
        IF processed_blocks %% 100 = 0 THEN
            RAISE NOTICE 'Progress: %% of %% blocks processed', processed_blocks, total_blocks;
        END IF;
    END LOOP;
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', processed_table_name) INTO total_comparisons;
    
    RAISE NOTICE 'Completed: %% blocks, %% comparisons in %%',
        processed_blocks, total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;

-- Updated compare_records_exhaustive to accept schema and table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema text DEFAULT 'public',
    records_table text DEFAULT 'records'
) RETURNS void AS $$
DECLARE
    total_records integer;
    start_time timestamp;
    total_comparisons integer := 0;
    full_table_name text;
    processed_table_name text;
BEGIN
    start_time := clock_timestamp();
    
    -- Build table names
    full_table_name := quote_ident(job_schema) || '.' || quote_ident(records_table);
    processed_table_name := quote_ident(job_schema) || '.processed_records';
    
    EXECUTE format('SELECT COUNT(*) FROM %%s', full_table_name) INTO total_records;
    
    RAISE NOTICE 'Starting exhaustive comparison of %% records from %%', total_records, full_table_name;
    
    -- Create exhaustive comparisons
    EXECUTE format('
        INSERT INTO %%s
        WITH age_data AS (
            SELECT 
                r.*,
                EXTRACT(YEAR FROM AGE(CURRENT_DATE, r.dob)) as age_years
            FROM %%s r
        )
        SELECT 
            r1.id, 
            r2.id,
            edit_distance(r1.last_name, r2.last_name),
            edit_distance(r1.phone, r2.phone),
            edit_distance(r1.middle_name, r2.middle_name),
            edit_distance(r1.zip, r2.zip),
            edit_distance(r1.city, r2.city),
            age_difference(r1.dob, r2.dob),
            CASE 
                WHEN r1.sex IS NULL OR r2.sex IS NULL THEN -1
                WHEN r1.sex != r2.sex THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.ssn IS NULL OR r2.ssn IS NULL THEN -1
                WHEN r1.ssn = r2.ssn THEN 1
                ELSE 0 
            END,
            CASE 
                WHEN r1.state IS NULL OR r2.state IS NULL THEN -1
                WHEN r1.state = r2.state THEN 1
                ELSE 0 
            END,
            edit_distance(r1.address, r2.address),
            CASE 
                WHEN r1.sex IS NULL THEN -1
                WHEN r1.sex = ''M'' THEN 0
                WHEN r1.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r2.sex IS NULL THEN -1
                WHEN r2.sex = ''M'' THEN 0
                WHEN r2.sex = ''F'' THEN 1
                ELSE -1
            END,
            CASE 
                WHEN r1.age_years IS NULL THEN -1
                WHEN r1.age_years < 18 THEN 0
                WHEN r1.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END,
            CASE 
                WHEN r2.age_years IS NULL THEN -1
                WHEN r2.age_years < 18 THEN 0
                WHEN r2.age_years BETWEEN 18 AND 50 THEN 1
                ELSE 2
            END
        FROM age_data r1
        JOIN age_data r2 ON r1.id < r2.id
        ON CONFLICT (from_id, to_id) DO NOTHING
    ', processed_table_name, full_table_name);
    
    GET DIAGNOSTICS total_comparisons = ROW_COUNT;
    
    RAISE NOTICE 'Exhaustive processing complete: %% matches found in %%',
        total_comparisons, clock_timestamp() - start_time;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:54:47,356 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 14:54:47,378 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 14:54:47,385 - __main__ - INFO - Normalized column: last_name
2025-09-03 14:54:47,388 - __main__ - INFO - Normalized column: middle_name
2025-09-03 14:54:47,391 - __main__ - INFO - Normalized column: address
2025-09-03 14:54:47,394 - __main__ - INFO - Normalized column: city
2025-09-03 14:54:47,397 - __main__ - INFO - Normalized column: state
2025-09-03 14:54:47,400 - __main__ - INFO - Converted DOB to datetime
2025-09-03 14:54:47,401 - __main__ - INFO - Cleaned SSN column
2025-09-03 14:54:47,402 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 14:54:47,402 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 14:54:47,561 - __main__ - INFO - PostgreSQL functions initialized with schema/table support
2025-09-03 14:54:47,686 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 14:54:47,686 - __main__ - INFO - Created database engine for public.records
2025-09-03 14:54:47,697 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 14:54:47,701 - __main__ - ERROR - Error in compare function: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:54:47,701 - __main__ - ERROR - Error in main: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.InvalidFunctionDefinition: cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 105, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/../family_linkage_models/prediction.py", line 46, in compare
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:54:56,077 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 14:54:56,086 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 14:54:56,089 - __main__ - INFO - Normalized column: last_name
2025-09-03 14:54:56,091 - __main__ - INFO - Normalized column: middle_name
2025-09-03 14:54:56,095 - __main__ - INFO - Normalized column: address
2025-09-03 14:54:56,098 - __main__ - INFO - Normalized column: city
2025-09-03 14:54:56,101 - __main__ - INFO - Normalized column: state
2025-09-03 14:54:56,103 - __main__ - INFO - Converted DOB to datetime
2025-09-03 14:54:56,103 - __main__ - INFO - Cleaned SSN column
2025-09-03 14:54:56,104 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 14:54:56,105 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 14:54:56,156 - __main__ - INFO - PostgreSQL functions initialized with schema/table support
2025-09-03 14:54:56,238 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 14:54:56,239 - __main__ - INFO - Created database engine for public.records
2025-09-03 14:54:56,246 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 14:54:56,250 - __main__ - ERROR - Error in compare function: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 14:54:56,250 - __main__ - ERROR - Error in main: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.InvalidFunctionDefinition: cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 105, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/../family_linkage_models/prediction.py", line 46, in compare
    connection.execute(text(sql_commands))
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1306, in execute
    return meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/sql/elements.py", line 332, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1498, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1862, in _execute_context
    self._handle_dbapi_exception(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 2043, in _handle_dbapi_exception
    util.raise_(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/util/compat.py", line 208, in raise_
    raise exception
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/base.py", line 1819, in _execute_context
    self.dialect.do_execute(
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sqlalchemy/engine/default.py", line 732, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.InvalidFunctionDefinition) cannot change return type of existing function
HINT:  Use DROP FUNCTION compare_records_exhaustive(text,text) first.

[SQL: -- Updated PostgreSQL functions following Chris's specifications
-- Functions now accept job_schema and records_table parameters

-- Function to create blocking keys with schema/table parameters
CREATE OR REPLACE FUNCTION create_blocking_keys(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_records INTEGER;
    processed_records INTEGER := 0;
    current_batch INTEGER;
    sql_query TEXT;
BEGIN
    -- Get total record count
    sql_query := format('SELECT COUNT(*) FROM %%I.%%I', job_schema, records_table);
    EXECUTE sql_query INTO total_records;
    
    -- Drop and recreate record_blocks table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.record_blocks', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.record_blocks (
            gid INTEGER,
            block_key TEXT,
            PRIMARY KEY (gid, block_key)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Create blocking keys in batches
    WHILE processed_records < total_records LOOP
        current_batch := LEAST(batch_size, total_records - processed_records);
        
        sql_query := format('
            INSERT INTO %%I.record_blocks (gid, block_key)
            SELECT gid, 
                   COALESCE(SUBSTRING(fname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(lname, 1, 2), '''') || 
                   COALESCE(SUBSTRING(CAST(byear AS TEXT), 3, 2), '''') as block_key
            FROM %%I.%%I 
            WHERE gid > %%s AND gid <= %%s
            AND (fname IS NOT NULL OR lname IS NOT NULL OR byear IS NOT NULL)',
            job_schema, job_schema, records_table, processed_records, processed_records + current_batch);
        
        EXECUTE sql_query;
        processed_records := processed_records + current_batch;
        
        RAISE NOTICE 'Processed %% of %% records (%%.1f%%%%)', 
            processed_records, total_records, 
            (processed_records::FLOAT / total_records * 100);
    END LOOP;
    
    -- Create index for performance
    sql_query := format('CREATE INDEX IF NOT EXISTS idx_record_blocks_key ON %%I.record_blocks(block_key)', job_schema);
    EXECUTE sql_query;
    
    RETURN processed_records;
END;
$$ LANGUAGE plpgsql;

-- Function for optimized record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_optimized(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records',
    min_gid_1 INTEGER DEFAULT 1,
    max_gid_1 INTEGER DEFAULT 50,
    min_gid_2 INTEGER DEFAULT 51,
    max_gid_2 INTEGER DEFAULT 100,
    max_block_size INTEGER DEFAULT 500,
    batch_size INTEGER DEFAULT 100000
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert record pairs using blocking
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT DISTINCT
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.record_blocks b1
        JOIN %%I.record_blocks b2 ON b1.block_key = b2.block_key
        JOIN %%I.%%I r1 ON b1.gid = r1.gid
        JOIN %%I.%%I r2 ON b2.gid = r2.gid
        WHERE r1.gid >= %%s AND r1.gid <= %%s
        AND r2.gid >= %%s AND r2.gid <= %%s
        AND r1.gid < r2.gid
        AND b1.block_key IN (
            SELECT block_key 
            FROM %%I.record_blocks 
            GROUP BY block_key 
            HAVING COUNT(*) <= %%s
        )',
        job_schema, job_schema, job_schema, job_schema, records_table, 
        job_schema, records_table, min_gid_1, max_gid_1, min_gid_2, max_gid_2,
        job_schema, max_block_size);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;

-- Function for exhaustive record comparison with schema/table parameters
CREATE OR REPLACE FUNCTION compare_records_exhaustive(
    job_schema TEXT DEFAULT 'public',
    records_table TEXT DEFAULT 'records'
) RETURNS INTEGER AS $$
DECLARE
    total_pairs INTEGER := 0;
    sql_query TEXT;
BEGIN
    -- Drop and recreate processed_records table in the same schema
    sql_query := format('DROP TABLE IF EXISTS %%I.processed_records', job_schema);
    EXECUTE sql_query;
    
    sql_query := format('
        CREATE TABLE %%I.processed_records (
            gid_1 INTEGER,
            gid_2 INTEGER,
            fname_1 TEXT, lname_1 TEXT, byear_1 INTEGER, bmonth_1 INTEGER, bday_1 INTEGER,
            fname_2 TEXT, lname_2 TEXT, byear_2 INTEGER, bmonth_2 INTEGER, bday_2 INTEGER,
            PRIMARY KEY (gid_1, gid_2)
        )', job_schema);
    EXECUTE sql_query;
    
    -- Insert all possible record pairs (exhaustive comparison)
    sql_query := format('
        INSERT INTO %%I.processed_records 
        SELECT 
            r1.gid as gid_1, r2.gid as gid_2,
            r1.fname as fname_1, r1.lname as lname_1, r1.byear as byear_1, 
            r1.bmonth as bmonth_1, r1.bday as bday_1,
            r2.fname as fname_2, r2.lname as lname_2, r2.byear as byear_2,
            r2.bmonth as bmonth_2, r2.bday as bday_2
        FROM %%I.%%I r1
        CROSS JOIN %%I.%%I r2
        WHERE r1.gid < r2.gid',
        job_schema, job_schema, records_table, job_schema, records_table);
    
    EXECUTE sql_query;
    
    -- Get count of inserted pairs
    sql_query := format('SELECT COUNT(*) FROM %%I.processed_records', job_schema);
    EXECUTE sql_query INTO total_pairs;
    
    RAISE NOTICE 'Generated %% record pairs (exhaustive)', total_pairs;
    RETURN total_pairs;
END;
$$ LANGUAGE plpgsql;
]
(Background on this error at: https://sqlalche.me/e/14/f405)
2025-09-03 20:11:08,665 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 20:11:08,678 - __main__ - INFO - Read 2000 records
2025-09-03 20:11:08,678 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 20:11:08,681 - __main__ - INFO - Normalized column: last_name
2025-09-03 20:11:08,683 - __main__ - INFO - Normalized column: middle_name
2025-09-03 20:11:08,687 - __main__ - INFO - Normalized column: address
2025-09-03 20:11:08,690 - __main__ - INFO - Normalized column: city
2025-09-03 20:11:08,692 - __main__ - INFO - Normalized column: state
2025-09-03 20:11:08,695 - __main__ - INFO - Converted DOB to datetime
2025-09-03 20:11:08,696 - __main__ - INFO - Cleaned SSN column
2025-09-03 20:11:08,696 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 20:11:08,696 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 20:11:08,870 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 20:11:08,870 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 20:11:08,878 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 20:11:08,878 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 20:11:08,878 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 20:11:08,887 - __main__ - INFO - Cleaned up existing tables
2025-09-03 20:11:08,887 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-03 20:11:08,887 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-03 20:11:08,887 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-03 20:13:54,081 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-03 20:14:22,374 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-03 20:14:22,377 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-03 20:14:22,424 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-03 20:14:22,425 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-03 20:14:31,322 - __main__ - INFO - Extracted 1999000 processed record pairs
2025-09-03 20:14:32,228 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-03 20:14:39,594 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-03 20:14:42,860 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 20:16:17,171 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 20:16:17,188 - __main__ - INFO - Read 2000 records
2025-09-03 20:16:17,188 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 20:16:17,191 - __main__ - INFO - Normalized column: last_name
2025-09-03 20:16:17,193 - __main__ - INFO - Normalized column: middle_name
2025-09-03 20:16:17,197 - __main__ - INFO - Normalized column: address
2025-09-03 20:16:17,200 - __main__ - INFO - Normalized column: city
2025-09-03 20:16:17,202 - __main__ - INFO - Normalized column: state
2025-09-03 20:16:17,204 - __main__ - INFO - Converted DOB to datetime
2025-09-03 20:16:17,204 - __main__ - INFO - Cleaned SSN column
2025-09-03 20:16:17,205 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 20:16:17,205 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 20:16:17,525 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 20:16:17,525 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 20:16:17,535 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 20:16:17,535 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 20:16:17,535 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 20:16:19,604 - __main__ - INFO - Cleaned up existing tables
2025-09-03 20:16:19,604 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 20:16:19,604 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 20:16:19,604 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 20:16:20,822 - __main__ - INFO - Merging blocking tables...
2025-09-03 20:16:20,867 - __main__ - INFO - Merged to 5837 blocking entries with 5183 unique blocks
2025-09-03 20:16:20,867 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 20:16:22,126 - __main__ - INFO - Merging comparison results...
2025-09-03 20:16:22,143 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 20:16:22,143 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-03 20:16:22,144 - __main__ - INFO - Progress 100%: Generated 934 record pairs
2025-09-03 20:16:22,144 - __main__ - INFO - Comparison complete: 934 record pairs generated
2025-09-03 20:16:22,150 - __main__ - INFO - Extracted 934 processed record pairs
2025-09-03 20:16:22,956 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-03 20:16:23,015 - __main__ - INFO - Generated predictions for 934 record pairs
2025-09-03 20:16:23,019 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 20:32:54,445 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 20:32:54,466 - __main__ - INFO - Read 2000 records
2025-09-03 20:32:54,466 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 20:32:54,472 - __main__ - INFO - Normalized column: last_name
2025-09-03 20:32:54,475 - __main__ - INFO - Normalized column: middle_name
2025-09-03 20:32:54,480 - __main__ - INFO - Normalized column: address
2025-09-03 20:32:54,483 - __main__ - INFO - Normalized column: city
2025-09-03 20:32:54,485 - __main__ - INFO - Normalized column: state
2025-09-03 20:32:54,487 - __main__ - INFO - Converted DOB to datetime
2025-09-03 20:32:54,487 - __main__ - INFO - Cleaned SSN column
2025-09-03 20:32:54,489 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 20:32:54,489 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 20:32:54,803 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 20:32:54,803 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 20:32:54,823 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 20:32:54,823 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 20:32:54,823 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 20:32:54,836 - __main__ - INFO - Cleaned up existing tables
2025-09-03 20:32:54,836 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-03 20:32:54,836 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-03 20:32:54,836 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-03 20:34:40,952 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-03 20:35:13,339 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-03 20:35:13,340 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-03 20:35:13,391 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-03 20:35:13,392 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-03 20:35:23,081 - __main__ - INFO - Extracted 1999000 processed record pairs
2025-09-03 20:35:24,037 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-03 20:35:31,665 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-03 20:35:35,971 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 20:36:51,958 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 20:36:51,980 - __main__ - INFO - Read 2000 records
2025-09-03 20:36:51,980 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 20:36:51,987 - __main__ - INFO - Normalized column: last_name
2025-09-03 20:36:51,989 - __main__ - INFO - Normalized column: middle_name
2025-09-03 20:36:51,993 - __main__ - INFO - Normalized column: address
2025-09-03 20:36:51,996 - __main__ - INFO - Normalized column: city
2025-09-03 20:36:51,998 - __main__ - INFO - Normalized column: state
2025-09-03 20:36:52,003 - __main__ - INFO - Converted DOB to datetime
2025-09-03 20:36:52,004 - __main__ - INFO - Cleaned SSN column
2025-09-03 20:36:52,005 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 20:36:52,005 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 20:36:52,293 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 20:36:52,293 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 20:36:52,303 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 20:36:52,303 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 20:36:52,303 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 20:36:53,971 - __main__ - INFO - Cleaned up existing tables
2025-09-03 20:36:53,971 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 20:36:53,971 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 20:36:53,971 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 20:36:55,256 - __main__ - INFO - Merging blocking tables...
2025-09-03 20:36:55,303 - __main__ - INFO - Merged to 5837 blocking entries with 5183 unique blocks
2025-09-03 20:36:55,303 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 20:36:56,579 - __main__ - INFO - Merging comparison results...
2025-09-03 20:36:56,595 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 20:36:56,596 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-03 20:36:56,596 - __main__ - INFO - Progress 100%: Generated 934 record pairs
2025-09-03 20:36:56,596 - __main__ - INFO - Comparison complete: 934 record pairs generated
2025-09-03 20:36:56,602 - __main__ - INFO - Extracted 934 processed record pairs
2025-09-03 20:36:57,397 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-03 20:36:57,454 - __main__ - INFO - Generated predictions for 934 record pairs
2025-09-03 20:36:57,682 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 21:27:17,969 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 21:27:17,993 - __main__ - INFO - Read 2000 records
2025-09-03 21:27:17,993 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 21:27:18,003 - __main__ - INFO - Normalized column: last_name
2025-09-03 21:27:18,005 - __main__ - INFO - Normalized column: middle_name
2025-09-03 21:27:18,009 - __main__ - INFO - Normalized column: address
2025-09-03 21:27:18,012 - __main__ - INFO - Normalized column: city
2025-09-03 21:27:18,015 - __main__ - INFO - Normalized column: state
2025-09-03 21:27:18,016 - __main__ - INFO - Converted DOB to datetime
2025-09-03 21:27:18,017 - __main__ - INFO - Cleaned SSN column
2025-09-03 21:27:18,018 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 21:27:18,018 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 21:27:18,387 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 21:27:18,387 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 21:27:18,410 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 21:27:18,410 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 21:27:18,410 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 21:27:18,427 - __main__ - INFO - Cleaned up existing tables
2025-09-03 21:27:18,427 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 21:27:18,427 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 21:27:18,427 - __main__ - ERROR - Error in compare: name '_run_parallel_optimized_comparison' is not defined
2025-09-03 21:27:18,428 - __main__ - ERROR - Error in main: name '_run_parallel_optimized_comparison' is not defined
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 125, in main
    compare(
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 65, in compare
    _run_parallel_optimized_comparison(
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
NameError: name '_run_parallel_optimized_comparison' is not defined
2025-09-03 21:48:37,534 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 21:48:37,592 - __main__ - INFO - Read 2000 records
2025-09-03 21:48:37,592 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 21:48:37,602 - __main__ - INFO - Normalized column: last_name
2025-09-03 21:48:37,604 - __main__ - INFO - Normalized column: middle_name
2025-09-03 21:48:37,609 - __main__ - INFO - Normalized column: address
2025-09-03 21:48:37,611 - __main__ - INFO - Normalized column: city
2025-09-03 21:48:37,614 - __main__ - INFO - Normalized column: state
2025-09-03 21:48:37,615 - __main__ - INFO - Converted DOB to datetime
2025-09-03 21:48:37,615 - __main__ - INFO - Cleaned SSN column
2025-09-03 21:48:37,617 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 21:48:37,617 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 21:48:38,216 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 21:48:38,216 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 21:48:38,227 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 21:48:38,228 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 21:48:38,228 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 21:48:38,233 - __main__ - INFO - Cleaned up existing tables
2025-09-03 21:48:38,233 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 21:48:38,233 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 21:48:38,233 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 21:48:39,559 - __main__ - INFO - Merging blocking tables...
2025-09-03 21:48:39,670 - __main__ - INFO - Merged to 5837 blocking entries with 5181 unique blocks
2025-09-03 21:48:39,670 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 21:48:40,997 - __main__ - INFO - Merging comparison results...
2025-09-03 21:48:41,018 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 21:48:41,018 - __main__ - INFO - Progress 90%: Merging processed records
2025-09-03 21:48:41,021 - __main__ - INFO - Progress 100%: Comparison complete
2025-09-03 21:48:44,072 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 21:48:44,072 - __main__ - ERROR - Error in main: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 205, in main
    print(f"Record pairs: {len(final_results) if final_results else 0}")
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/pandas/core/generic.py", line 1466, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2025-09-03 21:49:13,280 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 21:49:13,293 - __main__ - INFO - Read 2000 records
2025-09-03 21:49:13,294 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 21:49:13,302 - __main__ - INFO - Normalized column: last_name
2025-09-03 21:49:13,304 - __main__ - INFO - Normalized column: middle_name
2025-09-03 21:49:13,308 - __main__ - INFO - Normalized column: address
2025-09-03 21:49:13,311 - __main__ - INFO - Normalized column: city
2025-09-03 21:49:13,313 - __main__ - INFO - Normalized column: state
2025-09-03 21:49:13,314 - __main__ - INFO - Converted DOB to datetime
2025-09-03 21:49:13,314 - __main__ - INFO - Cleaned SSN column
2025-09-03 21:49:13,315 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 21:49:13,315 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 21:49:13,522 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 21:49:13,522 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 21:49:13,532 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 21:49:13,532 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 21:49:13,532 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 21:49:13,540 - __main__ - INFO - Cleaned up existing tables
2025-09-03 21:49:13,540 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 21:49:13,540 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-03 21:49:13,540 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 21:49:14,864 - __main__ - INFO - Merging blocking tables...
2025-09-03 21:49:14,934 - __main__ - INFO - Merged to 5837 blocking entries with 5181 unique blocks
2025-09-03 21:49:14,934 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 21:49:16,211 - __main__ - INFO - Merging comparison results...
2025-09-03 21:49:16,235 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 21:49:16,235 - __main__ - INFO - Progress 90%: Merging processed records
2025-09-03 21:49:16,238 - __main__ - INFO - Progress 100%: Comparison complete
2025-09-03 21:49:17,002 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 21:49:17,002 - __main__ - ERROR - Error in main: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 205, in main
    print(f"Record pairs: {len(final_results) if final_results else 0}")
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/pandas/core/generic.py", line 1466, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2025-09-03 21:49:20,424 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-03 21:49:20,432 - __main__ - INFO - Read 2000 records
2025-09-03 21:49:20,432 - __main__ - INFO - Starting normalization of 2000 records
2025-09-03 21:49:20,441 - __main__ - INFO - Normalized column: last_name
2025-09-03 21:49:20,443 - __main__ - INFO - Normalized column: middle_name
2025-09-03 21:49:20,447 - __main__ - INFO - Normalized column: address
2025-09-03 21:49:20,450 - __main__ - INFO - Normalized column: city
2025-09-03 21:49:20,452 - __main__ - INFO - Normalized column: state
2025-09-03 21:49:20,453 - __main__ - INFO - Converted DOB to datetime
2025-09-03 21:49:20,454 - __main__ - INFO - Cleaned SSN column
2025-09-03 21:49:20,454 - __main__ - INFO - Removed 0 placeholder records
2025-09-03 21:49:20,455 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-03 21:49:20,579 - __main__ - INFO - Loaded 2000 records to database
2025-09-03 21:49:20,579 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-03 21:49:20,586 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-03 21:49:20,586 - __main__ - INFO - Dataset size: 2000 records
2025-09-03 21:49:20,586 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-03 21:49:20,593 - __main__ - INFO - Cleaned up existing tables
2025-09-03 21:49:20,593 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-03 21:49:20,593 - __main__ - INFO - Using optimized blocking strategy (dataset > 1000)
2025-09-03 21:49:20,593 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-03 21:49:21,872 - __main__ - INFO - Merging blocking tables...
2025-09-03 21:49:21,945 - __main__ - INFO - Merged to 5837 blocking entries with 5181 unique blocks
2025-09-03 21:49:21,945 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-03 21:49:23,220 - __main__ - INFO - Merging comparison results...
2025-09-03 21:49:23,243 - __main__ - INFO - Merged 934 unique record pairs
2025-09-03 21:49:23,243 - __main__ - INFO - Progress 90%: Merging processed records
2025-09-03 21:49:23,245 - __main__ - INFO - Progress 100%: Comparison complete
2025-09-03 21:49:23,768 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-03 21:49:23,768 - __main__ - ERROR - Error in main: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 205, in main
    print(f"Record pairs: {len(final_results) if final_results else 0}")
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/pandas/core/generic.py", line 1466, in __nonzero__
    raise ValueError(
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
2025-09-04 00:31:42,023 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 00:31:42,023 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 00:31:42,023 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 00:31:42,025 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 00:31:42,041 - __main__ - INFO - Read 2000 records
2025-09-04 00:31:42,041 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 00:31:42,048 - __main__ - INFO - Normalized column: last_name
2025-09-04 00:31:42,050 - __main__ - INFO - Normalized column: middle_name
2025-09-04 00:31:42,054 - __main__ - INFO - Normalized column: address
2025-09-04 00:31:42,057 - __main__ - INFO - Normalized column: city
2025-09-04 00:31:42,059 - __main__ - INFO - Normalized column: state
2025-09-04 00:31:42,065 - __main__ - INFO - Converted DOB to datetime
2025-09-04 00:31:42,065 - __main__ - INFO - Cleaned SSN column
2025-09-04 00:31:42,066 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 00:31:42,066 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 00:31:42,422 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 00:31:42,422 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 00:31:42,433 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 00:31:42,433 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 00:31:42,433 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 00:31:45,154 - __main__ - INFO - Cleaned up existing tables
2025-09-04 00:31:45,155 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 00:31:45,155 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 00:31:45,155 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 00:34:33,548 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 00:34:59,795 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 00:34:59,797 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 00:34:59,844 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 00:34:59,844 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 00:35:00,079 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 00:35:00,158 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 00:35:40,072 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 00:35:40,073 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 00:40:41,920 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 00:40:41,922 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 00:40:41,922 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 00:40:41,923 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 00:40:41,946 - __main__ - INFO - Read 2000 records
2025-09-04 00:40:41,946 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 00:40:41,956 - __main__ - INFO - Normalized column: last_name
2025-09-04 00:40:41,959 - __main__ - INFO - Normalized column: middle_name
2025-09-04 00:40:41,963 - __main__ - INFO - Normalized column: address
2025-09-04 00:40:41,983 - __main__ - INFO - Normalized column: city
2025-09-04 00:40:41,986 - __main__ - INFO - Normalized column: state
2025-09-04 00:40:41,994 - __main__ - INFO - Converted DOB to datetime
2025-09-04 00:40:41,994 - __main__ - INFO - Cleaned SSN column
2025-09-04 00:40:41,995 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 00:40:41,995 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 00:40:42,323 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 00:40:42,323 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 00:40:42,336 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 00:40:42,336 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 00:40:42,336 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 00:40:44,746 - __main__ - INFO - Cleaned up existing tables
2025-09-04 00:40:44,747 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 00:40:44,747 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 00:40:44,747 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 00:43:18,322 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 00:43:55,085 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 00:43:55,091 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 00:43:55,138 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 00:43:55,139 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 00:43:55,393 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 00:43:55,482 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 00:44:31,713 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 00:44:31,714 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 00:45:23,925 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 00:45:23,925 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 00:45:23,925 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 00:45:23,926 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 00:45:23,949 - __main__ - INFO - Read 2000 records
2025-09-04 00:45:23,950 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 00:45:23,960 - __main__ - INFO - Normalized column: last_name
2025-09-04 00:45:23,962 - __main__ - INFO - Normalized column: middle_name
2025-09-04 00:45:23,966 - __main__ - INFO - Normalized column: address
2025-09-04 00:45:23,969 - __main__ - INFO - Normalized column: city
2025-09-04 00:45:23,971 - __main__ - INFO - Normalized column: state
2025-09-04 00:45:23,976 - __main__ - INFO - Converted DOB to datetime
2025-09-04 00:45:23,976 - __main__ - INFO - Cleaned SSN column
2025-09-04 00:45:23,978 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 00:45:23,978 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 00:45:24,262 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 00:45:24,262 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 00:45:24,271 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 00:45:24,271 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 00:45:24,271 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 00:45:27,113 - __main__ - INFO - Cleaned up existing tables
2025-09-04 00:45:27,113 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 00:45:27,113 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 00:45:27,113 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 00:48:17,523 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 00:48:46,022 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 00:48:46,023 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 00:48:46,070 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 00:48:46,071 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 00:48:46,428 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 00:48:46,515 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 00:49:20,565 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 00:49:20,566 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 00:49:36,419 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 00:49:36,419 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 00:49:36,419 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 00:49:36,421 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 00:49:36,437 - __main__ - INFO - Read 2000 records
2025-09-04 00:49:36,438 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 00:49:36,443 - __main__ - INFO - Normalized column: last_name
2025-09-04 00:49:36,445 - __main__ - INFO - Normalized column: middle_name
2025-09-04 00:49:36,449 - __main__ - INFO - Normalized column: address
2025-09-04 00:49:36,452 - __main__ - INFO - Normalized column: city
2025-09-04 00:49:36,455 - __main__ - INFO - Normalized column: state
2025-09-04 00:49:36,456 - __main__ - INFO - Converted DOB to datetime
2025-09-04 00:49:36,456 - __main__ - INFO - Cleaned SSN column
2025-09-04 00:49:36,457 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 00:49:36,457 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 00:49:36,741 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 00:49:36,741 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 00:49:36,750 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 00:49:36,750 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 00:49:36,750 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 00:49:37,970 - __main__ - INFO - Cleaned up existing tables
2025-09-04 00:49:37,970 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 00:49:37,970 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 00:49:37,970 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 00:49:40,517 - __main__ - INFO - Merging blocking tables...
2025-09-04 00:49:40,572 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 00:49:40,572 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 00:49:43,175 - __main__ - INFO - Merging comparison results...
2025-09-04 00:49:43,209 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 00:49:43,209 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 00:49:43,210 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 00:49:43,210 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 00:49:43,398 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 00:49:43,401 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 00:49:43,471 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 00:49:43,471 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 01:06:25,779 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 01:06:25,779 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 01:06:25,779 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 01:06:25,781 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 01:06:25,800 - __main__ - INFO - Read 2000 records
2025-09-04 01:06:25,800 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 01:06:25,809 - __main__ - INFO - Normalized column: last_name
2025-09-04 01:06:25,811 - __main__ - INFO - Normalized column: middle_name
2025-09-04 01:06:25,815 - __main__ - INFO - Normalized column: address
2025-09-04 01:06:25,818 - __main__ - INFO - Normalized column: city
2025-09-04 01:06:25,820 - __main__ - INFO - Normalized column: state
2025-09-04 01:06:25,822 - __main__ - INFO - Converted DOB to datetime
2025-09-04 01:06:25,823 - __main__ - INFO - Cleaned SSN column
2025-09-04 01:06:25,824 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 01:06:25,824 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 01:06:26,206 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 01:06:26,206 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 01:06:26,220 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 01:06:26,220 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 01:06:26,220 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 01:06:29,566 - __main__ - INFO - Cleaned up existing tables
2025-09-04 01:06:29,566 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 01:06:29,566 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 01:06:29,566 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 01:09:18,276 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 01:09:45,172 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 01:09:45,174 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 01:09:45,222 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 01:09:45,222 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 01:09:45,459 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 01:09:45,544 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 01:10:19,355 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 01:10:19,357 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 01:11:33,053 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 01:11:33,053 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 01:11:33,053 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 01:11:33,055 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 01:11:33,077 - __main__ - INFO - Read 2000 records
2025-09-04 01:11:33,078 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 01:11:33,087 - __main__ - INFO - Normalized column: last_name
2025-09-04 01:11:33,090 - __main__ - INFO - Normalized column: middle_name
2025-09-04 01:11:33,094 - __main__ - INFO - Normalized column: address
2025-09-04 01:11:33,096 - __main__ - INFO - Normalized column: city
2025-09-04 01:11:33,099 - __main__ - INFO - Normalized column: state
2025-09-04 01:11:33,104 - __main__ - INFO - Converted DOB to datetime
2025-09-04 01:11:33,104 - __main__ - INFO - Cleaned SSN column
2025-09-04 01:11:33,105 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 01:11:33,105 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 01:11:33,438 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 01:11:33,438 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 01:11:33,448 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 01:11:33,448 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 01:11:33,448 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 01:11:34,315 - __main__ - INFO - Cleaned up existing tables
2025-09-04 01:11:34,316 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 01:11:34,316 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 01:11:34,316 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 01:11:35,617 - __main__ - INFO - Merging blocking tables...
2025-09-04 01:11:35,676 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 01:11:35,677 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 01:11:37,204 - __main__ - INFO - Merging comparison results...
2025-09-04 01:11:37,235 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 01:11:37,235 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 01:11:37,236 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 01:11:37,236 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 01:11:38,063 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 01:11:38,066 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 01:11:38,140 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 01:11:38,140 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 01:11:45,621 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 01:11:45,621 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 01:11:45,621 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 01:11:45,623 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 01:11:45,630 - __main__ - INFO - Read 2000 records
2025-09-04 01:11:45,631 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 01:11:45,636 - __main__ - INFO - Normalized column: last_name
2025-09-04 01:11:45,639 - __main__ - INFO - Normalized column: middle_name
2025-09-04 01:11:45,643 - __main__ - INFO - Normalized column: address
2025-09-04 01:11:45,645 - __main__ - INFO - Normalized column: city
2025-09-04 01:11:45,648 - __main__ - INFO - Normalized column: state
2025-09-04 01:11:45,649 - __main__ - INFO - Converted DOB to datetime
2025-09-04 01:11:45,649 - __main__ - INFO - Cleaned SSN column
2025-09-04 01:11:45,650 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 01:11:45,650 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 01:11:45,761 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 01:11:45,762 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 01:11:45,768 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 01:11:45,768 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 01:11:45,768 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 01:11:45,774 - __main__ - INFO - Cleaned up existing tables
2025-09-04 01:11:45,774 - __main__ - INFO - Progress 30%: Using exhaustive comparison
2025-09-04 01:11:45,774 - __main__ - INFO - Using parallel exhaustive comparison (dataset <= 10000)
2025-09-04 01:11:45,774 - __main__ - INFO - Running parallel exhaustive comparison...
2025-09-04 01:14:31,441 - __main__ - INFO - Merging exhaustive comparison results...
2025-09-04 01:14:58,860 - __main__ - INFO - Merged 1999000 unique record pairs
2025-09-04 01:14:58,861 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 01:14:58,913 - __main__ - INFO - Progress 100%: Generated 1999000 record pairs
2025-09-04 01:14:58,913 - __main__ - INFO - Comparison complete: 1999000 record pairs generated
2025-09-04 01:14:59,898 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 01:14:59,978 - __main__ - INFO - Extracting 1999000 processed records in chunks of 50000
2025-09-04 01:15:33,793 - __main__ - INFO - Generated predictions for 1999000 record pairs
2025-09-04 01:15:33,794 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 01:17:22,406 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 01:17:22,406 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 01:17:22,406 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 01:17:22,408 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 01:17:22,431 - __main__ - INFO - Read 2000 records
2025-09-04 01:17:22,431 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 01:17:22,441 - __main__ - INFO - Normalized column: last_name
2025-09-04 01:17:22,443 - __main__ - INFO - Normalized column: middle_name
2025-09-04 01:17:22,447 - __main__ - INFO - Normalized column: address
2025-09-04 01:17:22,450 - __main__ - INFO - Normalized column: city
2025-09-04 01:17:22,453 - __main__ - INFO - Normalized column: state
2025-09-04 01:17:22,458 - __main__ - INFO - Converted DOB to datetime
2025-09-04 01:17:22,458 - __main__ - INFO - Cleaned SSN column
2025-09-04 01:17:22,459 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 01:17:22,459 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 01:17:22,734 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 01:17:22,734 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 01:17:22,745 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 01:17:22,745 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 01:17:22,745 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 01:17:23,227 - __main__ - INFO - Cleaned up existing tables
2025-09-04 01:17:23,228 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 01:17:23,228 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 01:17:23,228 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 01:17:24,435 - __main__ - INFO - Merging blocking tables...
2025-09-04 01:17:24,486 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 01:17:24,486 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 01:17:25,844 - __main__ - INFO - Merging comparison results...
2025-09-04 01:17:25,864 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 01:17:25,864 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 01:17:25,864 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 01:17:25,864 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 01:17:26,640 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 01:17:26,643 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 01:17:26,713 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 01:17:26,713 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 02:39:48,927 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 02:39:48,936 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 02:39:48,936 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:39:48,937 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
2025-09-04 02:40:47,220 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:40:47,222 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:40:47,241 - __main__ - INFO - Read 2000 records
2025-09-04 02:40:47,242 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:40:47,250 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:40:47,253 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:40:47,256 - __main__ - INFO - Normalized column: address
2025-09-04 02:40:47,259 - __main__ - INFO - Normalized column: city
2025-09-04 02:40:47,261 - __main__ - INFO - Normalized column: state
2025-09-04 02:40:47,263 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:40:47,264 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:40:47,265 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:40:47,265 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:40:47,681 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:40:47,681 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:40:47,695 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:40:47,695 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:40:47,695 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:40:47,715 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:40:47,715 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:40:47,715 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:40:47,715 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:40:49,026 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:40:49,106 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:40:49,106 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:40:50,448 - __main__ - INFO - Merging comparison results...
2025-09-04 02:40:50,472 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:40:50,472 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:40:50,473 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:40:50,473 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:40:51,336 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 02:40:51,339 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:40:51,409 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 02:40:51,409 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 02:41:02,787 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 02:41:02,787 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 02:41:02,787 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:41:02,789 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:42:45,978 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:42:45,980 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:42:46,002 - __main__ - INFO - Read 2000 records
2025-09-04 02:42:46,002 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:42:46,012 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:42:46,015 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:42:46,018 - __main__ - INFO - Normalized column: address
2025-09-04 02:42:46,021 - __main__ - INFO - Normalized column: city
2025-09-04 02:42:46,023 - __main__ - INFO - Normalized column: state
2025-09-04 02:42:46,028 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:42:46,028 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:42:46,030 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:42:46,030 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:42:46,215 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:42:46,215 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:42:46,222 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:42:46,222 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:42:46,222 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:42:46,229 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:42:46,229 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:42:46,229 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:42:46,229 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:42:47,504 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:42:47,562 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:42:47,562 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:42:48,801 - __main__ - INFO - Merging comparison results...
2025-09-04 02:42:48,824 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:42:48,824 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:42:48,825 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:42:48,825 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:42:49,600 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 02:42:49,602 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:42:49,671 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 02:42:49,671 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 02:43:04,135 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 02:43:04,135 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 02:43:04,135 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:43:04,136 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
2025-09-04 02:48:43,099 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:48:43,101 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
2025-09-04 02:50:31,087 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:50:31,088 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_mother_model.pkl
2025-09-04 02:50:43,630 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:50:43,632 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:51:42,453 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:51:42,455 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:51:42,478 - __main__ - INFO - Read 2000 records
2025-09-04 02:51:42,478 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:51:42,487 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:51:42,489 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:51:42,493 - __main__ - INFO - Normalized column: address
2025-09-04 02:51:42,496 - __main__ - INFO - Normalized column: city
2025-09-04 02:51:42,499 - __main__ - INFO - Normalized column: state
2025-09-04 02:51:42,504 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:51:42,504 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:51:42,505 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:51:42,505 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:51:42,819 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:51:42,819 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:51:42,828 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:51:42,828 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:51:42,828 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:51:42,839 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:51:42,840 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:51:42,840 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:51:42,840 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:51:44,287 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:51:44,341 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:51:44,341 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:51:45,624 - __main__ - INFO - Merging comparison results...
2025-09-04 02:51:45,653 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:51:45,653 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:51:45,653 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:51:45,653 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:51:46,492 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_sibling_model.pkl
2025-09-04 02:51:46,495 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:51:46,564 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 02:51:46,564 - __main__ - INFO - Saved predictions to data/predictions/predictions_sibling.csv
2025-09-04 02:52:52,562 - __main__ - INFO - Removed old file: data/predictions/predictions_sibling.csv
2025-09-04 02:52:52,562 - __main__ - INFO - Cleaned up 1 old files from data/predictions
2025-09-04 02:52:52,562 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:52:52,564 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:53:20,843 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:53:20,845 - __main__ - ERROR - Error in main: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 94, in main
    model_path = validate_model_exists(relationship_type, model_dir)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 61, in validate_model_exists
    raise FileNotFoundError(f"Model file not found: {model_path}")
FileNotFoundError: Model file not found: /Users/abhinavpundir/Downloads/family-linkage-fix/training_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:53:44,224 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:53:44,225 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:53:44,247 - __main__ - INFO - Read 2000 records
2025-09-04 02:53:44,248 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:53:44,256 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:53:44,258 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:53:44,262 - __main__ - INFO - Normalized column: address
2025-09-04 02:53:44,264 - __main__ - INFO - Normalized column: city
2025-09-04 02:53:44,267 - __main__ - INFO - Normalized column: state
2025-09-04 02:53:44,272 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:53:44,272 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:53:44,273 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:53:44,273 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:53:44,467 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:53:44,467 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:53:44,482 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:53:44,482 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:53:44,482 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:53:44,497 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:53:44,497 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:53:44,497 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:53:44,497 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:53:45,900 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:53:45,957 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:53:45,957 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:53:47,254 - __main__ - INFO - Merging comparison results...
2025-09-04 02:53:47,283 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:53:47,283 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:53:47,284 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:53:47,284 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:53:48,084 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:53:48,087 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:53:48,099 - __main__ - ERROR - Error in predict_chunked function: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:53:48,099 - __main__ - ERROR - Error in main: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 186, in main
    results_summary = predict_chunked(
                      ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 434, in predict_chunked
    predictions = model.predict(X)
                  ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 905, in predict
    proba = self.predict_proba(X)
            ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 947, in predict_proba
    X = self._validate_X_predict(X)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 641, in _validate_X_predict
    X = self._validate_data(
        ^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 608, in _validate_data
    self._check_feature_names(X, reset=reset)
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 535, in _check_feature_names
    raise ValueError(message)
ValueError: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:54:15,328 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:54:15,330 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:54:15,351 - __main__ - INFO - Read 2000 records
2025-09-04 02:54:15,352 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:54:15,361 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:54:15,363 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:54:15,367 - __main__ - INFO - Normalized column: address
2025-09-04 02:54:15,370 - __main__ - INFO - Normalized column: city
2025-09-04 02:54:15,372 - __main__ - INFO - Normalized column: state
2025-09-04 02:54:15,377 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:54:15,377 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:54:15,379 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:54:15,379 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:54:15,559 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:54:15,559 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:54:15,568 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:54:15,568 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:54:15,568 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:54:15,575 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:54:15,575 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:54:15,575 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:54:15,575 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:54:16,907 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:54:16,963 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:54:16,963 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:54:18,240 - __main__ - INFO - Merging comparison results...
2025-09-04 02:54:18,260 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:54:18,260 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:54:18,261 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:54:18,261 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:54:19,008 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:54:19,010 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:54:19,023 - __main__ - ERROR - Error in predict_chunked function: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:54:19,023 - __main__ - ERROR - Error in main: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 186, in main
    results_summary = predict_chunked(
                      ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 434, in predict_chunked
    predictions = model.predict(X)
                  ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 905, in predict
    proba = self.predict_proba(X)
            ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 947, in predict_proba
    X = self._validate_X_predict(X)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 641, in _validate_X_predict
    X = self._validate_data(
        ^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 608, in _validate_data
    self._check_feature_names(X, reset=reset)
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 535, in _check_feature_names
    raise ValueError(message)
ValueError: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:56:01,363 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 02:56:01,365 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 02:56:01,386 - __main__ - INFO - Read 2000 records
2025-09-04 02:56:01,387 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 02:56:01,396 - __main__ - INFO - Normalized column: last_name
2025-09-04 02:56:01,399 - __main__ - INFO - Normalized column: middle_name
2025-09-04 02:56:01,403 - __main__ - INFO - Normalized column: address
2025-09-04 02:56:01,405 - __main__ - INFO - Normalized column: city
2025-09-04 02:56:01,408 - __main__ - INFO - Normalized column: state
2025-09-04 02:56:01,413 - __main__ - INFO - Converted DOB to datetime
2025-09-04 02:56:01,414 - __main__ - INFO - Cleaned SSN column
2025-09-04 02:56:01,415 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 02:56:01,415 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 02:56:01,626 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 02:56:01,626 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 02:56:01,635 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 02:56:01,635 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 02:56:01,635 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 02:56:01,651 - __main__ - INFO - Cleaned up existing tables
2025-09-04 02:56:01,651 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 02:56:01,651 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 02:56:01,651 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 02:56:02,999 - __main__ - INFO - Merging blocking tables...
2025-09-04 02:56:03,050 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 02:56:03,050 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 02:56:04,329 - __main__ - INFO - Merging comparison results...
2025-09-04 02:56:04,348 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 02:56:04,348 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 02:56:04,349 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 02:56:04,349 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 02:56:05,095 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 02:56:05,098 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 02:56:05,110 - __main__ - ERROR - Error in predict_chunked function: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 02:56:05,110 - __main__ - ERROR - Error in main: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 186, in main
    results_summary = predict_chunked(
                      ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 434, in predict_chunked
    predictions = model.predict(X)
                  ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 905, in predict
    proba = self.predict_proba(X)
            ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 947, in predict_proba
    X = self._validate_X_predict(X)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 641, in _validate_X_predict
    X = self._validate_data(
        ^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 608, in _validate_data
    self._check_feature_names(X, reset=reset)
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 535, in _check_feature_names
    raise ValueError(message)
ValueError: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 03:11:38,773 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 03:11:38,775 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 03:11:38,796 - __main__ - INFO - Read 2000 records
2025-09-04 03:11:38,797 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 03:11:38,806 - __main__ - INFO - Normalized column: last_name
2025-09-04 03:11:38,809 - __main__ - INFO - Normalized column: middle_name
2025-09-04 03:11:38,812 - __main__ - INFO - Normalized column: address
2025-09-04 03:11:38,815 - __main__ - INFO - Normalized column: city
2025-09-04 03:11:38,818 - __main__ - INFO - Normalized column: state
2025-09-04 03:11:38,822 - __main__ - INFO - Converted DOB to datetime
2025-09-04 03:11:38,823 - __main__ - INFO - Cleaned SSN column
2025-09-04 03:11:38,824 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 03:11:38,824 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 03:11:39,162 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 03:11:39,162 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 03:11:39,172 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 03:11:39,172 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 03:11:39,172 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 03:11:39,186 - __main__ - INFO - Cleaned up existing tables
2025-09-04 03:11:39,186 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 03:11:39,186 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 03:11:39,186 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 03:11:40,422 - __main__ - INFO - Merging blocking tables...
2025-09-04 03:11:40,484 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 03:11:40,484 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 03:11:41,743 - __main__ - INFO - Merging comparison results...
2025-09-04 03:11:41,764 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 03:11:41,765 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 03:11:41,765 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 03:11:41,765 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 03:11:42,570 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 03:11:42,573 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 03:11:42,585 - __main__ - ERROR - Error in predict_chunked function: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 03:11:42,585 - __main__ - ERROR - Error in main: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match
Traceback (most recent call last):
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/main.py", line 186, in main
    results_summary = predict_chunked(
                      ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/family-linkage-fix/family_linkage_models/prediction.py", line 434, in predict_chunked
    predictions = model.predict(X)
                  ^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 905, in predict
    proba = self.predict_proba(X)
            ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 947, in predict_proba
    X = self._validate_X_predict(X)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/ensemble/_forest.py", line 641, in _validate_X_predict
    X = self._validate_data(
        ^^^^^^^^^^^^^^^^^^^^
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 608, in _validate_data
    self._check_feature_names(X, reset=reset)
  File "/Users/abhinavpundir/Downloads/AnaConda/anaconda3/lib/python3.11/site-packages/sklearn/base.py", line 535, in _check_feature_names
    raise ValueError(message)
ValueError: The feature names should match those that were passed during fit.
Feature names unseen at fit time:
- record1_agecategory
- record1_sex
- record2_agecategory
- record2_sex
Feature names seen at fit time, yet now missing:
- city_match
- edit_dist_dob
- zip_match

2025-09-04 03:14:13,781 - __main__ - INFO - Previous predictions cleaned up
2025-09-04 03:14:13,782 - __main__ - INFO - Reading test dataset from data/test/testing_dataset.csv
2025-09-04 03:14:13,807 - __main__ - INFO - Read 2000 records
2025-09-04 03:14:13,807 - __main__ - INFO - Starting normalization of 2000 records
2025-09-04 03:14:13,816 - __main__ - INFO - Normalized column: last_name
2025-09-04 03:14:13,819 - __main__ - INFO - Normalized column: middle_name
2025-09-04 03:14:13,822 - __main__ - INFO - Normalized column: address
2025-09-04 03:14:13,825 - __main__ - INFO - Normalized column: city
2025-09-04 03:14:13,827 - __main__ - INFO - Normalized column: state
2025-09-04 03:14:13,833 - __main__ - INFO - Converted DOB to datetime
2025-09-04 03:14:13,833 - __main__ - INFO - Cleaned SSN column
2025-09-04 03:14:13,834 - __main__ - INFO - Removed 0 placeholder records
2025-09-04 03:14:13,834 - __main__ - INFO - Normalization complete: 2000 records remaining
2025-09-04 03:14:14,032 - __main__ - INFO - Loaded 2000 records to database
2025-09-04 03:14:14,032 - __main__ - INFO - Progress 10%: Creating database connection
2025-09-04 03:14:14,041 - __main__ - INFO - Progress 20%: Dataset loaded: 2000 records
2025-09-04 03:14:14,041 - __main__ - INFO - Dataset size: 2000 records
2025-09-04 03:14:14,041 - __main__ - INFO - Progress 25%: Cleaning up existing tables
2025-09-04 03:14:14,058 - __main__ - INFO - Cleaned up existing tables
2025-09-04 03:14:14,058 - __main__ - INFO - Progress 30%: Using optimized blocking strategy
2025-09-04 03:14:14,058 - __main__ - INFO - Using optimized blocking strategy (dataset > 100)
2025-09-04 03:14:14,058 - __main__ - INFO - Creating blocking keys in parallel...
2025-09-04 03:14:15,336 - __main__ - INFO - Merging blocking tables...
2025-09-04 03:14:15,388 - __main__ - INFO - Merged to 5837 blocking entries with 5177 unique blocks
2025-09-04 03:14:15,388 - __main__ - INFO - Performing parallel optimized record comparison...
2025-09-04 03:14:16,697 - __main__ - INFO - Merging comparison results...
2025-09-04 03:14:16,714 - __main__ - INFO - Merged 969 unique record pairs
2025-09-04 03:14:16,714 - __main__ - INFO - Progress 90%: Comparison completed
2025-09-04 03:14:16,715 - __main__ - INFO - Progress 100%: Generated 969 record pairs
2025-09-04 03:14:16,715 - __main__ - INFO - Comparison complete: 969 record pairs generated
2025-09-04 03:14:17,521 - __main__ - INFO - Loaded model from /Users/abhinavpundir/Downloads/family-linkage-fix/test_pipeline/data/models/rf_partner_model.pkl
2025-09-04 03:14:17,523 - __main__ - INFO - Extracting 969 processed records in chunks of 50000
2025-09-04 03:14:17,592 - __main__ - INFO - Generated predictions for 969 record pairs
2025-09-04 03:14:17,592 - __main__ - INFO - Saved predictions to data/predictions/predictions_partner.csv
